# Data Model: AnalyzedRequirements Schema Migration

## Core Entities

### Requirements (New Schema)
The new data structure that replaces `analyzedRequirements`.

**Fields**:
- `goal` (string, required): The primary business objective describing what the user wants to achieve
- `testcases` (array of Testcase, required): Collection of test scenarios derived from the goal

**Relationships**:
- Generated by: PM Agent
- Consumed by: QA Agent, Routing Logic
- Replaces: AnalyzedRequirements entity

**Validation Rules**:
- `goal` must be non-empty string
- `testcases` must be valid array (can be empty initially)
- Each testcase must conform to Testcase schema

**State Transitions**:
```
PM Agent → Create Requirements {goal, testcases: [{ title, type }]}
QA Agent → Generate SQL for each testcase
QA Agent → Update testcases with SQL
Test Tool → Execute testcases and populate testResults
```

### Testcase (New Schema)
A structured test scenario with SQL operation details.

**Fields**:
- `title` (string, required): Descriptive name of the test case
- `type` (enum, required): SQL operation type - one of `'INSERT' | 'UPDATE' | 'DELETE' | 'SELECT'`
- `sql` (string, required): The SQL query for this test
  - Not generated by PM Agent (tool schema omits this field)
  - Generated by QA Agent
- `testResults` (TestResult, optional): Test execution result with structure:
  - `executedAt` (ISO datetime string): When the test was executed
  - `success` (boolean): Whether the test passed
  - `resultSummary` (string): Summary of test execution result

**Relationships**:
- Belongs to: Requirements
- SQL generated by: QA Agent
- Executed by: Test execution tool (runTestTool)

**Validation Rules**:
- `title` must be non-empty string
- `type` must be exactly one of: INSERT, UPDATE, DELETE, SELECT
- `sql` must be valid SQL string (validated before saving)
- `testResults` populated after test execution with execution logs

**State Transitions**:
```
PM Agent → Create Testcase {title, type}
            (PM tool schema omits sql field - LLM doesn't see it)
QA Agent → Generate SQL and populate testcase.sql
            (QA tool schema includes sql field - LLM generates it)
Test Tool → Execute SQL and populate testResults with execution logs
```

### AnalyzedRequirements (Legacy - To Be Removed)
The old data structure being deprecated.

**Fields**:
- `businessRequirement` (string): Legacy name for business objective
- `functionalRequirements` (array): Legacy unstructured requirements array

**Relationships**:
- Generated by: PM Agent (Phase 1-2 only)
- Will be removed: Phase 3

**Migration Status**:
- Phase 1: Coexists with Requirements
- Phase 2: Reads migrated to Requirements
- Phase 3: Removed completely

## State Schema Definition

### LangGraph Annotation (TypeScript)

```typescript
import { Annotation } from '@langchain/langgraph';

// New Requirements Schema
const RequirementsAnnotation = Annotation.Root({
  goal: Annotation<string>(),
  testcases: Annotation<Array<{
    title: string;
    type: 'INSERT' | 'UPDATE' | 'DELETE' | 'SELECT';
    sql: string;
    testResults?: unknown;
  }>>({
    reducer: (_, y) => y, // Replace strategy
    default: () => [],
  }),
});

// Agent State with Requirements
const AgentStateAnnotation = Annotation.Root({
  // ... other state fields
  requirements: Annotation<{
    goal: string;
    testcases: Array<{
      title: string;
      type: 'INSERT' | 'UPDATE' | 'DELETE' | 'SELECT';
      sql: string; // Required in state annotation
      testResults?: unknown;
    }>;
  }>(),
  // Legacy field (Phase 1-2 only)
  analyzedRequirements?: Annotation<{
    businessRequirement: string;
    functionalRequirements: unknown[];
  }>(),
});

// Note: PM Agent tool schema uses pmAgentTestcaseSchema (omits sql)
//       to prevent LLM from generating SQL

```

### Valibot Runtime Validation

```typescript
import * as v from 'valibot';

const testcaseTypeEnum = v.picklist(['INSERT', 'UPDATE', 'DELETE', 'SELECT']);

// Test result schema
const testResultSchema = v.object({
  executedAt: v.pipe(v.string(), v.isoDateTime()),
  success: v.boolean(),
  resultSummary: v.string(),
});

// Complete testcase schema (with sql required)
const testcaseSchema = v.object({
  title: v.string(),
  type: testcaseTypeEnum,
  sql: v.string(), // Required in state
  testResults: v.optional(testResultSchema),
});

// PM Agent testcase schema (sql omitted to prevent LLM from generating it)
const pmAgentTestcaseSchema = v.omit(testcaseSchema, ['sql', 'testResults']);

const requirementsSchema = v.object({
  goal: v.string(),
  testcases: v.array(testcaseSchema),
});

// PM Agent requirements schema (uses pmAgentTestcaseSchema)
const pmAgentRequirementsSchema = v.object({
  goal: v.string(),
  testcases: v.array(pmAgentTestcaseSchema),
});
```

## Entity Relationships

```
┌─────────────┐
│  PM Agent   │
│             │
│  Generates  │
└─────┬───────┘
      │
      │ creates (goal + testcases with title/type)
      ▼
┌─────────────────┐
│  Requirements   │
│                 │
│  - goal         │
│  - testcases[]  │
└─────┬───────────┘
      │
      │ contains
      ▼
┌─────────────────┐
│   Testcase      │
│                 │
│  - title        │
│  - type         │
│  - sql          │ ← Generated by QA Agent
│  - testResults  │ ← Populated by Test Tool
└─────┬───────────┘
      │
      │ generates SQL for
      ▼
┌─────────────┐          ┌──────────────┐
│  QA Agent   │          │  Test Tool   │
│             │          │              │
│  SQL Gen    │          │  Executes    │
└─────────────┘          └──────────────┘
                                │
                                │ populates testResults
                                ▼
                         (back to Testcase)
```

## Migration Path

### Phase 1: Parallel Fields
```typescript
interface AgentState {
  requirements: {          // New field
    goal: string;
    testcases: Testcase[];
  };
  analyzedRequirements: {  // Legacy field
    businessRequirement: string;
    functionalRequirements: unknown[];
  };
}
```

### Phase 2: Transition Reads
```typescript
// PM Agent writes to both (temporary)
// QA Agent reads from requirements only
// Routing logic reads from requirements only
```

### Phase 3: Remove Legacy
```typescript
interface AgentState {
  requirements: {          // Only new field remains
    goal: string;
    testcases: Testcase[];
  };
}
```

## Data Flow

### PM Agent → Requirements Creation
1. Analyze user input
2. Generate goal string
3. Derive testcases from goal (title, type only)
4. PM Agent tool schema omits `sql` field - LLM doesn't see it and won't generate it
5. Create Requirements object with goal + testcases (without SQL)
6. Update state with requirements field

### QA Agent → SQL Generation
1. Read requirements.testcases array (without SQL)
2. Validate each testcase.type against enum
3. QA Agent tool schema includes `sql` field - LLM sees it and generates SQL
4. Generate SQL for each testcase based on title and type
5. Validate SQL syntax using pgParse
6. Save testcase with generated SQL using saveTestcaseTool
7. Return updated testcases with SQL

### Test Execution → Results Population
1. Execute DDL setup
2. Run each testcase SQL operation
3. Collect execution results (success/failure, logs)
4. Populate testcase.testResults with execution logs
5. Return updated testcases with test results

### State Updates
- PM Agent: Uses tool with pmAgentRequirementsSchema (sql field omitted)
  - Tool output: `{ requirements: { goal, testcases: [{ title, type }] } }`
- QA Agent: Uses tool with full testcase schema (sql field included)
  - Tool output: `{ requirements: { ...state.requirements, testcases: [{ title, type, sql }] } }`
- Test Tool: Updates testcases with testResults after execution
- Routing: Check `state.requirements?.goal` and `state.requirements?.testcases?.length`
