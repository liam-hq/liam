import { createInMemoryRepositories, deepModeling } from '@liam-hq/agent'
import { err, ok, type Result } from 'neverthrow'
import type { LiamDBExecutorInput, LiamDBExecutorOutput } from './types.ts'

export const createLiamDBExecutorOffline = () => {
  const execute = async (
    input: LiamDBExecutorInput,
  ): Promise<Result<LiamDBExecutorOutput, Error>> => {
    try {
      // Create shared repositories and session
      const repositories = createInMemoryRepositories()
      const designSessionId = `offline-session-${Date.now()}`
      const buildingSchemaId = `offline-schema-${Date.now()}`

      // Create a simple logger for offline mode
      const logger = {
        log: (_message: string) => {},
        error: (message: string) => console.error(`[DeepModeling] ${message}`),
        warn: (message: string) => console.warn(`[DeepModeling] ${message}`),
        debug: (_message: string) => {},
        info: (_message: string) => {},
      }
      const deepModelingResult = await deepModeling(
        {
          userInput: input.input,
          schemaData: { tables: {} },
          history: [],
          organizationId: 'offline-org',
          buildingSchemaId,
          latestVersionNumber: 0,
          designSessionId,
          userId: 'offline-user',
          recursionLimit: 15,
        },
        {
          configurable: {
            repositories,
            logger,
          },
        },
      )

      if (!deepModelingResult.isOk()) {
        console.error(
          `❌ Deep modeling failed: ${deepModelingResult.error.message}`,
        )
        return err(
          new Error(
            `Deep modeling failed: ${deepModelingResult.error.message}`,
          ),
        )
      }

      // Extract the generated schema from memory repositories
      const inMemoryRepo = repositories.schema as any
      
      // Debug: log repository state
      console.log('Repository state:')
      console.log('- schemaVersions size:', inMemoryRepo.schemaVersions?.size || 0)
      console.log('- schemas size:', inMemoryRepo.schemas?.size || 0)
      
      // Try to get the final schema from the schema versions
      if (inMemoryRepo.schemaVersions && inMemoryRepo.schemaVersions.size > 0) {
        console.log('Checking schemaVersions...')
        // Get the latest schema version
        for (const [key, versionData] of inMemoryRepo.schemaVersions.entries()) {
          console.log(`  Version ${key}:`, {
            hasSchema: !!versionData.schema,
            tableCount: versionData.schema ? Object.keys(versionData.schema.tables).length : 0
          })
          if (versionData.schema && Object.keys(versionData.schema.tables).length > 0) {
            console.log('Found schema in schemaVersions!')
            console.log('Tables found:', Object.keys(versionData.schema.tables))
            return ok({
              tables: versionData.schema.tables,
            })
          }
        }
      }
      
      // Fallback to checking the main schemas map
      if (inMemoryRepo.schemas && inMemoryRepo.schemas.size > 0) {
        console.log('Checking schemas map...')
        for (const [key, schemaData] of inMemoryRepo.schemas.entries()) {
          console.log(`  Schema ${key}:`, {
            hasSchema: !!schemaData.schema,
            tableCount: schemaData.schema ? Object.keys(schemaData.schema.tables).length : 0
          })
          if (schemaData.schema && Object.keys(schemaData.schema.tables).length > 0) {
            console.log('Found schema in schemas map!')
            return ok({
              tables: schemaData.schema.tables,
            })
          }
        }
      }
      
      console.error('❌ No schema found in repository after deep modeling')
      console.error('Repository debug info:')
      console.error('- schemaVersions keys:', Array.from(inMemoryRepo.schemaVersions?.keys() || []))
      console.error('- schemas keys:', Array.from(inMemoryRepo.schemas?.keys() || []))
      
      return err(
        new Error('No schema was generated by the deep modeling process'),
      )
    } catch (error) {
      if (error instanceof Error) {
        return err(error)
      }
      return err(new Error('Unknown error occurred'))
    }
  }

  return { execute }
}
