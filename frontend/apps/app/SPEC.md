# Web Application Package Specification

## 1. Overview
### 1.1 Purpose
The @liam-hq/app package is the main Next.js web application that serves as the user-facing interface for both Liam ERD and Liam DB services. It provides a comprehensive web platform for database schema visualization, AI-powered schema design, and collaborative database development workflows.

### 1.2 Scope
This application encompasses:

#### Frontend User Interface
- **Interactive ERD Visualization**: Web-based schema diagram viewing and interaction
- **AI-Powered Chat Interface**: Conversational database design and management
- **Real-time Collaboration**: Multi-user design sessions with live updates
- **Project Management**: Organization, project, and repository management
- **Authentication & Authorization**: GitHub OAuth and user session management

#### API Layer
- **REST API Endpoints**: Next.js API routes for data operations
- **WebSocket Integration**: Real-time updates via Supabase subscriptions
- **External API Integration**: GitHub, OpenAI, and Supabase API interactions
- **Background Job Processing**: Trigger.dev integration for async operations

#### Core Features
- **Schema Processing**: Upload and parse various schema formats
- **ERD Generation**: Interactive diagram generation from schema files
- **AI Agents**: Multi-agent database design workflow (PM, Architect, QA)
- **GitHub Integration**: Repository synchronization and PR analysis
- **User Management**: Organization and team collaboration features

### 1.3 Terminology
- **Design Session**: Collaborative AI-powered database design workspace
- **Project**: GitHub repository connection with schema tracking
- **Organization**: Team/company workspace for multiple users
- **Branch**: Git branch context for schema versioning
- **Timeline Item**: Chat message or AI response in design sessions
- **Building Schema**: In-progress schema being generated by AI agents
- **ERD Viewer**: Schema visualization component using React Flow

## 2. Functional Requirements
### 2.1 Core Features
#### 2.1.1 Authentication & User Management
- **GitHub OAuth**: Secure authentication via GitHub accounts
- **Organization Management**: Create and manage team organizations
- **User Invitations**: Invite team members to organizations
- **Session Management**: Persistent login sessions with security

#### 2.1.2 Project & Repository Management
- **GitHub Integration**: Connect and sync with GitHub repositories
- **Project Creation**: Add repositories as projects within organizations
- **Branch Selection**: Choose specific branches for schema tracking
- **Schema Detection**: Automatically detect schema files in repositories

#### 2.1.3 ERD Visualization
- **Interactive Diagrams**: Pan, zoom, and navigate large schema diagrams
- **Schema Upload**: Support for PostgreSQL, Prisma, Rails schema.rb, TBLS formats
- **Public Sharing**: Share diagrams via public URLs
- **Export Capabilities**: Download diagrams in various formats

#### 2.1.4 AI-Powered Database Design
- **Natural Language Input**: Describe database requirements in plain language
- **Multi-Agent Workflow**: PM, DB Architect, and QA agent collaboration
- **Real-time Generation**: Live schema building with instant feedback
- **Iterative Refinement**: Continuous improvement through conversation
- **Schema Validation**: SQL execution testing in safe environment

#### 2.1.5 Collaborative Features
- **Design Sessions**: Multi-user real-time collaboration
- **Chat Interface**: Conversational interaction with AI agents
- **Version History**: Track schema changes over time
- **Team Management**: Organization member and permission management

### 2.2 Use Cases
#### 2.2.1 Quick Schema Visualization
1. User uploads schema file or provides GitHub URL
2. System parses schema and generates interactive ERD
3. User explores diagram with filtering and navigation tools
4. User shares diagram via public URL or exports for documentation

#### 2.2.2 AI-Powered Database Design
1. User creates new design session with project context
2. User describes requirements in natural language
3. AI agents collaborate to generate optimized schema
4. User iterates and refines through conversation
5. Final schema is validated and exported

#### 2.2.3 Team Collaboration
1. Organization admin invites team members
2. Team creates shared projects from GitHub repositories
3. Members collaborate on design sessions with real-time updates
4. Schema changes are tracked and versioned

### 2.3 Constraints
- Must handle concurrent users with real-time updates
- Requires secure authentication and authorization
- Must integrate with multiple external APIs reliably
- Should provide responsive UI across device sizes
- Must maintain data consistency across distributed components

## 3. Technical Specifications
### 3.1 Architecture
```typescript
// Application structure
app/
├── app/                          // Next.js 15 App Router
│   ├── (app)/                   // Main authenticated app routes
│   ├── api/                     // Next.js API routes
│   ├── auth/                    // Authentication callbacks
│   ├── erd/                     // Public ERD viewer
│   └── layout.tsx               // Root layout
├── components/                   // React components
│   ├── Chat/                    // AI chat interface
│   ├── CommonLayout/            // Shared layout components
│   ├── ERDEditor/               // Schema visualization
│   └── [Feature]Page/           // Page-specific components
├── features/                     // Feature-specific logic
├── libs/                        // Shared libraries
│   ├── db/                      // Database clients
│   ├── routes/                  // Route management
│   └── gtm/                     // Analytics
└── utils/                       // Utility functions
```

### 3.2 Data Model
```typescript
// Core application types
interface User {
  id: string;
  email: string;
  github_username: string;
  avatar_url: string;
}

interface Organization {
  id: string;
  name: string;
  created_by: string;
  members: OrganizationMember[];
}

interface Project {
  id: string;
  name: string;
  repository_url: string;
  organization_id: string;
  github_installation_id: number;
}

interface DesignSession {
  id: string;
  project_id: string;
  branch_name: string;
  title: string;
  created_by: string;
  timeline_items: TimelineItem[];
}

interface TimelineItem {
  id: string;
  session_id: string;
  type: 'user_message' | 'agent_message' | 'version_message';
  content: string;
  metadata?: Record<string, any>;
  created_at: string;
}

interface BuildingSchema {
  id: string;
  session_id: string;
  version: number;
  schema_content: string;
  status: 'building' | 'completed' | 'failed';
}
```

### 3.3 API Specification
```typescript
// Next.js API Routes
// Authentication
POST /api/auth/github              // GitHub OAuth callback
GET  /api/auth/user                // Get current user

// Projects
GET    /api/projects               // List user projects
POST   /api/projects               // Create new project
GET    /api/projects/[id]          // Get project details
DELETE /api/projects/[id]          // Delete project

// Design Sessions
GET  /api/sessions                 // List sessions
POST /api/sessions                 // Create session
GET  /api/sessions/[id]            // Get session details
POST /api/sessions/[id]/messages   // Send message to session

// Schema Building
GET  /api/buildingSchemas/versions // Get building schema versions
POST /api/chat                     // Chat with AI agents

// Webhooks
POST /api/webhook/github           // GitHub webhook handler
```

## 4. Interfaces
### 4.1 External Interfaces
- **GitHub API**: Repository access, webhook processing, OAuth
- **OpenAI API**: AI agent conversations and schema generation
- **Supabase**: Database operations, real-time subscriptions, authentication
- **Trigger.dev**: Background job orchestration and monitoring

### 4.2 Internal Interfaces
- **@liam-hq/erd-core**: ERD visualization rendering
- **@liam-hq/db-structure**: Schema parsing and validation
- **@liam-hq/ui**: UI component library and design system
- **@liam-hq/github**: GitHub API wrappers and utilities
- **@liam-hq/jobs**: Background job definitions and handlers

### 4.3 Dependencies
- **React 18 & Next.js 15**: Frontend framework and routing
- **TypeScript**: Type safety and development experience
- **Valtio**: State management for reactive updates
- **@xyflow/react**: Interactive diagram rendering
- **Supabase**: Database client and real-time subscriptions
- **NextAuth.js**: Authentication with GitHub OAuth
- **Sentry**: Error monitoring and performance tracking
- **Tailwind CSS**: Styling framework

## 5. Non-functional Requirements
### 5.1 Performance
- Page load time < 2 seconds for initial render
- Real-time updates < 500ms latency
- Support concurrent users (100+ per organization)
- Efficient rendering for large schemas (100+ tables)

### 5.2 Security
- Secure GitHub OAuth implementation
- API rate limiting and CSRF protection
- Input validation and sanitization
- Secure session management
- Environment-based configuration

### 5.3 Scalability
- Horizontal scaling via Vercel serverless functions
- Database connection pooling
- CDN for static assets
- Background job processing for heavy operations

### 5.4 Reliability
- Error boundary implementation for React components
- Graceful degradation when services are unavailable
- Automatic retry mechanisms for failed operations
- Comprehensive error logging and monitoring

## 6. Implementation Details
### 6.1 State Management
- **Valtio**: Reactive state for real-time collaboration
- **React Context**: Authentication and organization state
- **URL State**: Navigation and routing parameters
- **Local Storage**: User preferences and settings

### 6.2 Real-time Features
- **Supabase Subscriptions**: Real-time database updates
- **WebSocket Connections**: Live collaboration in design sessions
- **Optimistic Updates**: Immediate UI feedback before server confirmation
- **Conflict Resolution**: Handle concurrent edits gracefully

### 6.3 Error Handling
- **Error Boundaries**: Catch and display React component errors
- **API Error Handling**: Standardized error responses and user messaging
- **Retry Logic**: Automatic retry for transient failures
- **User Feedback**: Clear error messages with actionable next steps

### 6.4 Monitoring & Observability
- **Sentry Integration**: Exception tracking and performance monitoring
- **OpenTelemetry**: Distributed tracing with Vercel OTel integration for request monitoring  
- **Langfuse Integration**: AI operation tracing and analytics for LLM interactions
- **Request Error Capture**: Automatic error capture for Next.js API routes
- **Environment-based Configuration**: Different monitoring setups for development, staging, and production

*Note: Monitoring strategy follows platform-wide error handling approach defined in root SPEC.md*

## 7. Testing Strategy
### 7.1 Testing Priorities
#### 7.1.1 High Priority (Must Have)
**Critical User Flows:**
- User authentication and authorization (GitHub OAuth)
- Project creation and GitHub repository connection
- Design session creation and AI agent interaction
- Schema parsing and ERD visualization
- Real-time collaboration and updates

**Security & Data Integrity:**
- Authentication token validation and refresh
- API route authorization and input validation
- Organization member access controls
- Secure handling of GitHub tokens and API keys

#### 7.1.2 Medium Priority (Should Have)
**User Experience Flows:**
- Navigation between pages and route handling
- Form validation and error handling
- File upload and schema format detection
- Export functionality and public sharing
- Member invitation and organization management

**Integration Points:**
- External API error handling (GitHub, OpenAI, Supabase)
- Background job processing and status updates
- Real-time subscription management
- Cross-package component integration

#### 7.1.3 Low Priority (Nice to Have)
**Performance & Polish:**
- Large schema rendering performance
- Mobile responsiveness and touch interactions
- Accessibility compliance (WCAG 2.1)
- Visual regression testing for UI components
- Analytics and user behavior tracking

### 7.2 Test Types and Coverage
#### 7.2.1 Coverage Requirements
- **Unit Tests**: 80% minimum coverage for critical business logic
- **Integration Tests**: 90% coverage for API routes and database operations
- **E2E Tests**: 100% coverage for primary user journeys
- **Component Tests**: Visual and interaction testing for key components

#### 7.2.2 Test Distribution
- **Authentication flows**: Login, logout, session management
- **Project management**: CRUD operations, GitHub integration
- **Design sessions**: Chat interface, AI agent interactions
- **ERD visualization**: Schema rendering, user interactions
- **API routes**: Request/response validation, error handling
- **Real-time features**: WebSocket connections, collaborative updates

##### 7.2.2.1 Authentication Flow Test Requirements

**Business Logic Tests (Pure Functions - No Mocks Required):**
- **URL Handling**: Return URL determination, OAuth callback URL construction
- **User Data Processing**: Organization name generation from user metadata
- **Authentication Logic**: Login redirect decisions, OAuth state validation
- **Cookie Configuration**: Secure cookie settings for session management
- **Profile Extraction**: User profile data normalization from OAuth responses
- **Performance**: Pure functions execute <50ms for 1000 iterations

**Integration Tests (Dependency Injection - Minimal Mocks):**
- **OAuth Service Integration**: GitHub OAuth flow with injected dependencies
- **Middleware Integration**: Authentication checking with user data services  
- **Organization Services**: User organization creation with database operations
- **Error Handling**: Service layer error scenarios and recovery
- **Real-world Scenarios**: Complete authentication flows with composed functions

**Test Coverage Requirements:**
- **Pure Functions**: 100% line coverage (currently 35 tests, 4ms execution)
- **Integration Layer**: 90% path coverage (currently 12 tests, 5ms execution)
- **Performance Benchmarks**: All business logic functions <1ms individual execution
- **Error Scenarios**: All failure modes and edge cases covered

**Test Architecture Principles:**
- **Testable Design**: Pure functions separated from I/O operations
- **Dependency Injection**: Service layer uses injected dependencies for testability
- **Minimal Mocking**: Mock only I/O boundaries, test real business logic
- **Fast Execution**: Test suite completes in <100ms for rapid feedback

### 7.3 Validation Criteria
- **Functionality**: All user flows work as specified
- **Performance**: Meets response time and concurrency requirements
- **Security**: Passes security audit and penetration testing
- **Reliability**: 99.9% uptime with graceful error handling
- **Usability**: User testing validates interface design and workflows
