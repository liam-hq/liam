"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js ***!
  \******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeNames = void 0;\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nvar AttributeNames;\n(function (AttributeNames) {\n    AttributeNames[\"HTTP_ERROR_NAME\"] = \"http.error_name\";\n    AttributeNames[\"HTTP_ERROR_MESSAGE\"] = \"http.error_message\";\n    AttributeNames[\"HTTP_STATUS_TEXT\"] = \"http.status_text\";\n})(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));\n//# sourceMappingURL=AttributeNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvZW51bXMvQXR0cmlidXRlTmFtZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QyxzQkFBc0IsS0FBSztBQUMxRSIsInNvdXJjZXMiOlsiL1VzZXJzL3ByYWtoYXIvRG9jdW1lbnRzL29wZW5zX3NvdXJjZV9jb250cmlidXRpb25fMi9saWFtL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvZW51bXMvQXR0cmlidXRlTmFtZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BdHRyaWJ1dGVOYW1lcyA9IHZvaWQgMDtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktc3BlY2lmaWNhdGlvbi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uL3RyYWNlL3NlbWFudGljX2NvbnZlbnRpb25zL2h0dHAubWRcbiAqL1xudmFyIEF0dHJpYnV0ZU5hbWVzO1xuKGZ1bmN0aW9uIChBdHRyaWJ1dGVOYW1lcykge1xuICAgIEF0dHJpYnV0ZU5hbWVzW1wiSFRUUF9FUlJPUl9OQU1FXCJdID0gXCJodHRwLmVycm9yX25hbWVcIjtcbiAgICBBdHRyaWJ1dGVOYW1lc1tcIkhUVFBfRVJST1JfTUVTU0FHRVwiXSA9IFwiaHR0cC5lcnJvcl9tZXNzYWdlXCI7XG4gICAgQXR0cmlidXRlTmFtZXNbXCJIVFRQX1NUQVRVU19URVhUXCJdID0gXCJodHRwLnN0YXR1c190ZXh0XCI7XG59KShBdHRyaWJ1dGVOYW1lcyA9IGV4cG9ydHMuQXR0cmlidXRlTmFtZXMgfHwgKGV4cG9ydHMuQXR0cmlidXRlTmFtZXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXR0cmlidXRlTmFtZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\n");

/***/ }),

/***/ "(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(instrument)/../../../node_modules/.pnpm/semver@7.7.1/node_modules/semver/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst core_2 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\");\n/**\n * `node:http` and `node:https` instrumentation for OpenTelemetry\n */\nclass HttpInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super('@opentelemetry/instrumentation-http', version_1.VERSION, config);\n        /** keep track on spans not ended */\n        this._spanNotEnded = new WeakSet();\n        this._semconvStability = 2 /* OLD */;\n        this._headerCapture = this._createHeaderCapture();\n        for (const entry of (0, core_2.getEnv)().OTEL_SEMCONV_STABILITY_OPT_IN) {\n            if (entry.toLowerCase() === 'http/dup') {\n                // http/dup takes highest precedence. If it is found, there is no need to read the rest of the list\n                this._semconvStability = 3 /* DUPLICATE */;\n                break;\n            }\n            else if (entry.toLowerCase() === 'http') {\n                this._semconvStability = 1 /* STABLE */;\n            }\n        }\n    }\n    _updateMetricInstruments() {\n        this._oldHttpServerDurationHistogram = this.meter.createHistogram('http.server.duration', {\n            description: 'Measures the duration of inbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._oldHttpClientDurationHistogram = this.meter.createHistogram('http.client.duration', {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {\n            description: 'Duration of HTTP server requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n        this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Duration of HTTP client requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    _recordServerDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability & 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability & 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpServerDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    _recordClientDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability & 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability & 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpClientDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    setConfig(config = {}) {\n        super.setConfig(config);\n        this._headerCapture = this._createHeaderCapture();\n    }\n    init() {\n        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n    }\n    _getHttpInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports) => {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction('http'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import http from 'http'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('http'));\n            }\n            return moduleExports;\n        }, (moduleExports) => {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    _getHttpsInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports) => {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchHttpsOutgoingRequestFunction('https'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchHttpsOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import https from 'https'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('https'));\n            }\n            return moduleExports;\n        }, (moduleExports) => {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    /**\n     * Creates spans for incoming requests, restoring spans' context if applied.\n     */\n    _getPatchIncomingRequestFunction(component) {\n        return (original) => {\n            return this._incomingRequestFunction(component, original);\n        };\n    }\n    /**\n     * Creates spans for outgoing requests, sending spans' context for distributed\n     * tracing.\n     */\n    _getPatchOutgoingRequestFunction(component) {\n        return (original) => {\n            return this._outgoingRequestFunction(component, original);\n        };\n    }\n    _getPatchOutgoingGetFunction(clientRequest) {\n        return (_original) => {\n            // Re-implement http.get. This needs to be done (instead of using\n            // getPatchOutgoingRequestFunction to patch it) because we need to\n            // set the trace context header before the returned http.ClientRequest is\n            // ended. The Node.js docs state that the only differences between\n            // request and get are that (1) get defaults to the HTTP GET method and\n            // (2) the returned request object is ended immediately. The former is\n            // already true (at least in supported Node versions up to v10), so we\n            // simply follow the latter. Ref:\n            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n            return function outgoingGetRequest(options, ...args) {\n                const req = clientRequest(options, ...args);\n                req.end();\n                return req;\n            };\n        };\n    }\n    /** Patches HTTPS outgoing requests */\n    _getPatchHttpsOutgoingRequestFunction(component) {\n        return (original) => {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                var _a;\n                // Makes sure options will have default HTTPS parameters\n                if (component === 'https' &&\n                    typeof options === 'object' &&\n                    ((_a = options === null || options === void 0 ? void 0 : options.constructor) === null || _a === void 0 ? void 0 : _a.name) !== 'URL') {\n                    options = Object.assign({}, options);\n                    instrumentation._setDefaultOptions(options);\n                }\n                return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);\n            };\n        };\n    }\n    _setDefaultOptions(options) {\n        options.protocol = options.protocol || 'https:';\n        options.port = options.port || 443;\n    }\n    /** Patches HTTPS outgoing get requests */\n    _getPatchHttpsOutgoingGetFunction(clientRequest) {\n        return (original) => {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);\n            };\n        };\n    }\n    /**\n     * Attach event listeners to a client request to end span and add span attributes.\n     *\n     * @param request The original request object.\n     * @param span representing the current operation\n     * @param startTime representing the start time of the request to calculate duration in Metric\n     * @param oldMetricAttributes metric attributes for old semantic conventions\n     * @param stableMetricAttributes metric attributes for new semantic conventions\n     */\n    _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (this.getConfig().requestHook) {\n            this._callRequestHook(span, request);\n        }\n        /**\n         * Determines if the request has errored or the response has ended/errored.\n         */\n        let responseFinished = false;\n        /*\n         * User 'response' event listeners can be added before our listener,\n         * force our listener to be the first, so response emitter is bound\n         * before any user listeners are added to it.\n         */\n        request.prependListener('response', (response) => {\n            this._diag.debug('outgoingRequest on response()');\n            if (request.listenerCount('response') <= 1) {\n                response.resume();\n            }\n            const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);\n            span.setAttributes(responseAttributes);\n            oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));\n            if (this.getConfig().responseHook) {\n                this._callResponseHook(span, response);\n            }\n            this._headerCapture.client.captureRequestHeaders(span, header => request.getHeader(header));\n            this._headerCapture.client.captureResponseHeaders(span, header => response.headers[header]);\n            api_1.context.bind(api_1.context.active(), response);\n            const endHandler = () => {\n                this._diag.debug('outgoingRequest on end()');\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                let status;\n                if (response.aborted && !response.complete) {\n                    status = { code: api_1.SpanStatusCode.ERROR };\n                }\n                else {\n                    // behaves same for new and old semconv\n                    status = {\n                        code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode),\n                    };\n                }\n                span.setStatus(status);\n                if (this.getConfig().applyCustomAttributesOnSpan) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => { }, true);\n                }\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            };\n            response.on('end', endHandler);\n            // See https://github.com/open-telemetry/opentelemetry-js/pull/3625#issuecomment-1475673533\n            if (semver.lt(process.version, '16.0.0')) {\n                response.on('close', endHandler);\n            }\n            response.on(events_1.errorMonitor, (error) => {\n                this._diag.debug('outgoingRequest on error()', error);\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: error.message,\n                });\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        });\n        request.on('close', () => {\n            this._diag.debug('outgoingRequest on request close()');\n            if (request.aborted || responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        request.on(events_1.errorMonitor, (error) => {\n            this._diag.debug('outgoingRequest on request error()', error);\n            if (responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        this._diag.debug('http.ClientRequest return request');\n        return request;\n    }\n    _incomingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function incomingRequest(event, ...args) {\n            // Only traces request events\n            if (event !== 'request') {\n                return original.apply(this, [event, ...args]);\n            }\n            const request = args[0];\n            const response = args[1];\n            const method = request.method || 'GET';\n            instrumentation._diag.debug(`${component} instrumentation incomingRequest`);\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => { var _a, _b; return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, request); }, (e) => {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreIncomingRequestHook error: ', e);\n                }\n            }, true)) {\n                return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {\n                    api_1.context.bind(api_1.context.active(), request);\n                    api_1.context.bind(api_1.context.active(), response);\n                    return original.apply(this, [event, ...args]);\n                });\n            }\n            const headers = request.headers;\n            const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {\n                component: component,\n                serverName: instrumentation.getConfig().serverName,\n                hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),\n                semconvStability: instrumentation._semconvStability,\n            }, instrumentation._diag);\n            const spanOptions = {\n                kind: api_1.SpanKind.SERVER,\n                attributes: spanAttributes,\n            };\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);\n            // request method and url.scheme are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME],\n            };\n            // recommended if and only if one was sent, same as span recommendation\n            if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n            const span = instrumentation._startHttpSpan(method, spanOptions, ctx);\n            const rpcMetadata = {\n                type: core_2.RPCType.HTTP,\n                span,\n            };\n            return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () => {\n                api_1.context.bind(api_1.context.active(), request);\n                api_1.context.bind(api_1.context.active(), response);\n                if (instrumentation.getConfig().requestHook) {\n                    instrumentation._callRequestHook(span, request);\n                }\n                if (instrumentation.getConfig().responseHook) {\n                    instrumentation._callResponseHook(span, response);\n                }\n                instrumentation._headerCapture.server.captureRequestHeaders(span, header => request.headers[header]);\n                // After 'error', no further events other than 'close' should be emitted.\n                let hasError = false;\n                response.on('close', () => {\n                    if (hasError) {\n                        return;\n                    }\n                    instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);\n                });\n                response.on(events_1.errorMonitor, (err) => {\n                    hasError = true;\n                    instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);\n                });\n                return (0, instrumentation_1.safeExecuteInTheMiddle)(() => original.apply(this, [event, ...args]), error => {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n            });\n        };\n    }\n    _outgoingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function outgoingRequest(options, ...args) {\n            if (!(0, utils_1.isValidOptionsType)(options)) {\n                return original.apply(this, [options, ...args]);\n            }\n            const extraOptions = typeof args[0] === 'object' &&\n                (typeof options === 'string' || options instanceof url.URL)\n                ? args.shift()\n                : undefined;\n            const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);\n            /**\n             * Node 8's https module directly call the http one so to avoid creating\n             * 2 span for the same request we need to check that the protocol is correct\n             * See: https://github.com/nodejs/node/blob/v8.17.0/lib/https.js#L245\n             */\n            if (component === 'http' &&\n                semver.lt(process.version, '9.0.0') &&\n                optionsParsed.protocol === 'https:') {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() => {\n                var _a, _b;\n                return (_b = (_a = instrumentation\n                    .getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, optionsParsed);\n            }, (e) => {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreOutgoingRequestHook error: ', e);\n                }\n            }, true)) {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            const { hostname, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);\n            const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {\n                component,\n                port,\n                hostname,\n                hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook),\n            }, instrumentation._semconvStability);\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);\n            // request method, server address, and server port are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],\n                [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT],\n            };\n            // required if and only if one was sent, same as span requirement\n            if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n                    attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n            }\n            // recommended if and only if one was sent, same as span recommendation\n            if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const spanOptions = {\n                kind: api_1.SpanKind.CLIENT,\n                attributes,\n            };\n            const span = instrumentation._startHttpSpan(method, spanOptions);\n            const parentContext = api_1.context.active();\n            const requestContext = api_1.trace.setSpan(parentContext, span);\n            if (!optionsParsed.headers) {\n                optionsParsed.headers = {};\n            }\n            else {\n                // Make a copy of the headers object to avoid mutating an object the\n                // caller might have a reference to.\n                optionsParsed.headers = Object.assign({}, optionsParsed.headers);\n            }\n            api_1.propagation.inject(requestContext, optionsParsed.headers);\n            return api_1.context.with(requestContext, () => {\n                /*\n                 * The response callback is registered before ClientRequest is bound,\n                 * thus it is needed to bind it before the function call.\n                 */\n                const cb = args[args.length - 1];\n                if (typeof cb === 'function') {\n                    args[args.length - 1] = api_1.context.bind(parentContext, cb);\n                }\n                const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() => {\n                    if (invalidUrl) {\n                        // we know that the url is invalid, there's no point in injecting context as it will fail validation.\n                        // Passing in what the user provided will give the user an error that matches what they'd see without\n                        // the instrumentation.\n                        return original.apply(this, [options, ...args]);\n                    }\n                    else {\n                        return original.apply(this, [optionsParsed, ...args]);\n                    }\n                }, error => {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n                instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);\n                api_1.context.bind(parentContext, request);\n                return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        };\n    }\n    _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {\n        const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);\n        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));\n        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));\n        this._headerCapture.server.captureResponseHeaders(span, header => response.getHeader(header));\n        span.setAttributes(attributes).setStatus({\n            code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode),\n        });\n        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n        if (route) {\n            span.updateName(`${request.method || 'GET'} ${route}`);\n        }\n        if (this.getConfig().applyCustomAttributesOnSpan) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(span, request, response), () => { }, true);\n        }\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {\n        (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n        // TODO get error attributes for metrics\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _startHttpSpan(name, options, ctx = api_1.context.active()) {\n        /*\n         * If a parent is required but not present, we use a `NoopSpan` to still\n         * propagate context without recording it.\n         */\n        const requireParent = options.kind === api_1.SpanKind.CLIENT\n            ? this.getConfig().requireParentforOutgoingSpans\n            : this.getConfig().requireParentforIncomingSpans;\n        let span;\n        const currentSpan = api_1.trace.getSpan(ctx);\n        if (requireParent === true && currentSpan === undefined) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else if (requireParent === true && (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {\n            span = currentSpan;\n        }\n        else {\n            span = this.tracer.startSpan(name, options, ctx);\n        }\n        this._spanNotEnded.add(span);\n        return span;\n    }\n    _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (!this._spanNotEnded.has(span)) {\n            return;\n        }\n        span.end();\n        this._spanNotEnded.delete(span);\n        // Record metrics\n        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));\n        if (spanKind === api_1.SpanKind.SERVER) {\n            this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n        else if (spanKind === api_1.SpanKind.CLIENT) {\n            this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n    }\n    _callResponseHook(span, response) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(span, response), () => { }, true);\n    }\n    _callRequestHook(span, request) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(span, request), () => { }, true);\n    }\n    _callStartSpanHook(request, hookFunc) {\n        if (typeof hookFunc === 'function') {\n            return (0, instrumentation_1.safeExecuteInTheMiddle)(() => hookFunc(request), () => { }, true);\n        }\n    }\n    _createHeaderCapture() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const config = this.getConfig();\n        return {\n            client: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_c = (_b = (_a = config.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null && _c !== void 0 ? _c : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null && _f !== void 0 ? _f : []),\n            },\n            server: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null && _j !== void 0 ? _j : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null && _m !== void 0 ? _m : []),\n            },\n        };\n    }\n}\nexports.HttpInstrumentation = HttpInstrumentation;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvaHR0cC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdKQUFvQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsNktBQXFCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxrR0FBUTtBQUMvQixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsa0JBQWtCLG1CQUFPLENBQUMscU1BQVc7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsOE1BQWdDO0FBQ2xFLGVBQWUsbUJBQU8sQ0FBQyw2S0FBcUI7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsK0JBQStCLG1CQUFPLENBQUMsb01BQXFDO0FBQzVFLGdCQUFnQixtQkFBTyxDQUFDLGlNQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmFraGFyL0RvY3VtZW50cy9vcGVuc19zb3VyY2VfY29udHJpYnV0aW9uXzIvbGlhbS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2h0dHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBjb3JlXzIgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIGBub2RlOmh0dHBgIGFuZCBgbm9kZTpodHRwc2AgaW5zdHJ1bWVudGF0aW9uIGZvciBPcGVuVGVsZW1ldHJ5XG4gKi9cbmNsYXNzIEh0dHBJbnN0cnVtZW50YXRpb24gZXh0ZW5kcyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcignQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAnLCB2ZXJzaW9uXzEuVkVSU0lPTiwgY29uZmlnKTtcbiAgICAgICAgLyoqIGtlZXAgdHJhY2sgb24gc3BhbnMgbm90IGVuZGVkICovXG4gICAgICAgIHRoaXMuX3NwYW5Ob3RFbmRlZCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgPSAyIC8qIE9MRCAqLztcbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZSA9IHRoaXMuX2NyZWF0ZUhlYWRlckNhcHR1cmUoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiAoMCwgY29yZV8yLmdldEVudikoKS5PVEVMX1NFTUNPTlZfU1RBQklMSVRZX09QVF9JTikge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnRvTG93ZXJDYXNlKCkgPT09ICdodHRwL2R1cCcpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwL2R1cCB0YWtlcyBoaWdoZXN0IHByZWNlZGVuY2UuIElmIGl0IGlzIGZvdW5kLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJlYWQgdGhlIHJlc3Qgb2YgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW1jb252U3RhYmlsaXR5ID0gMyAvKiBEVVBMSUNBVEUgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW1jb252U3RhYmlsaXR5ID0gMSAvKiBTVEFCTEUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwZGF0ZU1ldHJpY0luc3RydW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9vbGRIdHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbSgnaHR0cC5zZXJ2ZXIuZHVyYXRpb24nLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01lYXN1cmVzIHRoZSBkdXJhdGlvbiBvZiBpbmJvdW5kIEhUVFAgcmVxdWVzdHMuJyxcbiAgICAgICAgICAgIHVuaXQ6ICdtcycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbGRIdHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbSgnaHR0cC5jbGllbnQuZHVyYXRpb24nLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01lYXN1cmVzIHRoZSBkdXJhdGlvbiBvZiBvdXRib3VuZCBIVFRQIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAnbXMnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3RhYmxlSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtYW50aWNfY29udmVudGlvbnNfMS5NRVRSSUNfSFRUUF9TRVJWRVJfUkVRVUVTVF9EVVJBVElPTiwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEdXJhdGlvbiBvZiBIVFRQIHNlcnZlciByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ3MnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICAgICAgYWR2aWNlOiB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsXG4gICAgICAgICAgICAgICAgICAgIDcuNSwgMTAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGFibGVIdHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbShzZW1hbnRpY19jb252ZW50aW9uc18xLk1FVFJJQ19IVFRQX0NMSUVOVF9SRVFVRVNUX0RVUkFUSU9OLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0R1cmF0aW9uIG9mIEhUVFAgY2xpZW50IHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAncycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgICAgICBhZHZpY2U6IHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdEJ1Y2tldEJvdW5kYXJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSxcbiAgICAgICAgICAgICAgICAgICAgNy41LCAxMCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWNvcmRTZXJ2ZXJEdXJhdGlvbihkdXJhdGlvbk1zLCBvbGRBdHRyaWJ1dGVzLCBzdGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICgodGhpcy5fc2VtY29udlN0YWJpbGl0eSAmIDIgLyogT0xEICovKSA9PT1cbiAgICAgICAgICAgIDIgLyogT0xEICovKSB7XG4gICAgICAgICAgICAvLyBvbGQgaGlzdG9ncmFtIGlzIGNvdW50ZWQgaW4gTVNcbiAgICAgICAgICAgIHRoaXMuX29sZEh0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25Ncywgb2xkQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLl9zZW1jb252U3RhYmlsaXR5ICYgMSAvKiBTVEFCTEUgKi8pID09PVxuICAgICAgICAgICAgMSAvKiBTVEFCTEUgKi8pIHtcbiAgICAgICAgICAgIC8vIHN0YWJsZSBoaXN0b2dyYW0gaXMgY291bnRlZCBpbiBTXG4gICAgICAgICAgICB0aGlzLl9zdGFibGVIdHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uTXMgLyAxMDAwLCBzdGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVjb3JkQ2xpZW50RHVyYXRpb24oZHVyYXRpb25Ncywgb2xkQXR0cmlidXRlcywgc3RhYmxlQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAyIC8qIE9MRCAqLykgPT09XG4gICAgICAgICAgICAyIC8qIE9MRCAqLykge1xuICAgICAgICAgICAgLy8gb2xkIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIE1TXG4gICAgICAgICAgICB0aGlzLl9vbGRIdHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fc2VtY29udlN0YWJpbGl0eSAmIDEgLyogU1RBQkxFICovKSA9PT1cbiAgICAgICAgICAgIDEgLyogU1RBQkxFICovKSB7XG4gICAgICAgICAgICAvLyBzdGFibGUgaGlzdG9ncmFtIGlzIGNvdW50ZWQgaW4gU1xuICAgICAgICAgICAgdGhpcy5fc3RhYmxlSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zIC8gMTAwMCwgc3RhYmxlQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q29uZmlnKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyLnNldENvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlID0gdGhpcy5fY3JlYXRlSGVhZGVyQ2FwdHVyZSgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuX2dldEh0dHBzSW5zdHJ1bWVudGF0aW9uKCksIHRoaXMuX2dldEh0dHBJbnN0cnVtZW50YXRpb24oKV07XG4gICAgfVxuICAgIF9nZXRIdHRwSW5zdHJ1bWVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdodHRwJywgWycqJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0VTTSA9IG1vZHVsZUV4cG9ydHNbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZSc7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSZXF1ZXN0ID0gdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcsIHRoaXMuX2dldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oJ2h0dHAnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZEdldCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcsIHRoaXMuX2dldFBhdGNoT3V0Z29pbmdHZXRGdW5jdGlvbihwYXRjaGVkUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VTTSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUbyBoYW5kbGUgYGltcG9ydCBodHRwIGZyb20gJ2h0dHAnYCwgd2hpY2ggcmV0dXJucyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvcnQsIHdlIG5lZWQgdG8gc2V0IGBtb2R1bGUuZGVmYXVsdC4qYC5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0cy5kZWZhdWx0LnJlcXVlc3QgPSBwYXRjaGVkUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0cy5kZWZhdWx0LmdldCA9IHBhdGNoZWRHZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVJbmNvbWluZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuU2VydmVyLnByb3RvdHlwZSwgJ2VtaXQnLCB0aGlzLl9nZXRQYXRjaEluY29taW5nUmVxdWVzdEZ1bmN0aW9uKCdodHRwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kdWxlRXhwb3J0cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlT3V0Z29pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdyZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdnZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuU2VydmVyLnByb3RvdHlwZSwgJ2VtaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRIdHRwc0luc3RydW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignaHR0cHMnLCBbJyonXSwgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzRVNNID0gbW9kdWxlRXhwb3J0c1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJztcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlT3V0Z29pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZFJlcXVlc3QgPSB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdyZXF1ZXN0JywgdGhpcy5fZ2V0UGF0Y2hIdHRwc091dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKCdodHRwcycpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkR2V0ID0gdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAnZ2V0JywgdGhpcy5fZ2V0UGF0Y2hIdHRwc091dGdvaW5nR2V0RnVuY3Rpb24ocGF0Y2hlZFJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFU00pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gaGFuZGxlIGBpbXBvcnQgaHR0cHMgZnJvbSAnaHR0cHMnYCwgd2hpY2ggcmV0dXJucyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvcnQsIHdlIG5lZWQgdG8gc2V0IGBtb2R1bGUuZGVmYXVsdC4qYC5cbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0cy5kZWZhdWx0LnJlcXVlc3QgPSBwYXRjaGVkUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0cy5kZWZhdWx0LmdldCA9IHBhdGNoZWRHZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVJbmNvbWluZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuU2VydmVyLnByb3RvdHlwZSwgJ2VtaXQnLCB0aGlzLl9nZXRQYXRjaEluY29taW5nUmVxdWVzdEZ1bmN0aW9uKCdodHRwcycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgICB9LCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnZ2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZUluY29taW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHNwYW5zIGZvciBpbmNvbWluZyByZXF1ZXN0cywgcmVzdG9yaW5nIHNwYW5zJyBjb250ZXh0IGlmIGFwcGxpZWQuXG4gICAgICovXG4gICAgX2dldFBhdGNoSW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBzcGFucyBmb3Igb3V0Z29pbmcgcmVxdWVzdHMsIHNlbmRpbmcgc3BhbnMnIGNvbnRleHQgZm9yIGRpc3RyaWJ1dGVkXG4gICAgICogdHJhY2luZy5cbiAgICAgKi9cbiAgICBfZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZ2V0UGF0Y2hPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIChfb3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIC8vIFJlLWltcGxlbWVudCBodHRwLmdldC4gVGhpcyBuZWVkcyB0byBiZSBkb25lIChpbnN0ZWFkIG9mIHVzaW5nXG4gICAgICAgICAgICAvLyBnZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uIHRvIHBhdGNoIGl0KSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNldCB0aGUgdHJhY2UgY29udGV4dCBoZWFkZXIgYmVmb3JlIHRoZSByZXR1cm5lZCBodHRwLkNsaWVudFJlcXVlc3QgaXNcbiAgICAgICAgICAgIC8vIGVuZGVkLiBUaGUgTm9kZS5qcyBkb2NzIHN0YXRlIHRoYXQgdGhlIG9ubHkgZGlmZmVyZW5jZXMgYmV0d2VlblxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhbmQgZ2V0IGFyZSB0aGF0ICgxKSBnZXQgZGVmYXVsdHMgdG8gdGhlIEhUVFAgR0VUIG1ldGhvZCBhbmRcbiAgICAgICAgICAgIC8vICgyKSB0aGUgcmV0dXJuZWQgcmVxdWVzdCBvYmplY3QgaXMgZW5kZWQgaW1tZWRpYXRlbHkuIFRoZSBmb3JtZXIgaXNcbiAgICAgICAgICAgIC8vIGFscmVhZHkgdHJ1ZSAoYXQgbGVhc3QgaW4gc3VwcG9ydGVkIE5vZGUgdmVyc2lvbnMgdXAgdG8gdjEwKSwgc28gd2VcbiAgICAgICAgICAgIC8vIHNpbXBseSBmb2xsb3cgdGhlIGxhdHRlci4gUmVmOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL2h0dHAuaHRtbCNodHRwX2h0dHBfZ2V0X29wdGlvbnNfY2FsbGJhY2tcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2Nsb3VkLXRyYWNlLW5vZGVqcy9ibG9iL21hc3Rlci9zcmMvaW5zdHJ1bWVudGF0aW9ucy9pbnN0cnVtZW50YXRpb24taHR0cC50cyNMMTk4XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gb3V0Z29pbmdHZXRSZXF1ZXN0KG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBjbGllbnRSZXF1ZXN0KG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFBhdGNoZXMgSFRUUFMgb3V0Z29pbmcgcmVxdWVzdHMgKi9cbiAgICBfZ2V0UGF0Y2hIdHRwc091dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBzT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgb3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlcyBzdXJlIG9wdGlvbnMgd2lsbCBoYXZlIGRlZmF1bHQgSFRUUFMgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09ICdodHRwcycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gJ1VSTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX3NldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9nZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkob3JpZ2luYWwpKG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3NldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgJ2h0dHBzOic7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucG9ydCB8fCA0NDM7XG4gICAgfVxuICAgIC8qKiBQYXRjaGVzIEhUVFBTIG91dGdvaW5nIGdldCByZXF1ZXN0cyAqL1xuICAgIF9nZXRQYXRjaEh0dHBzT3V0Z29pbmdHZXRGdW5jdGlvbihjbGllbnRSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gaHR0cHNPdXRnb2luZ1JlcXVlc3QoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICBvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZ2V0UGF0Y2hPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpKG9yaWdpbmFsKShvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gYSBjbGllbnQgcmVxdWVzdCB0byBlbmQgc3BhbiBhbmQgYWRkIHNwYW4gYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gc3BhbiByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IHRpbWUgb2YgdGhlIHJlcXVlc3QgdG8gY2FsY3VsYXRlIGR1cmF0aW9uIGluIE1ldHJpY1xuICAgICAqIEBwYXJhbSBvbGRNZXRyaWNBdHRyaWJ1dGVzIG1ldHJpYyBhdHRyaWJ1dGVzIGZvciBvbGQgc2VtYW50aWMgY29udmVudGlvbnNcbiAgICAgKiBAcGFyYW0gc3RhYmxlTWV0cmljQXR0cmlidXRlcyBtZXRyaWMgYXR0cmlidXRlcyBmb3IgbmV3IHNlbWFudGljIGNvbnZlbnRpb25zXG4gICAgICovXG4gICAgX3RyYWNlQ2xpZW50UmVxdWVzdChyZXF1ZXN0LCBzcGFuLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkucmVxdWVzdEhvb2spIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxSZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgcmVxdWVzdCBoYXMgZXJyb3JlZCBvciB0aGUgcmVzcG9uc2UgaGFzIGVuZGVkL2Vycm9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgcmVzcG9uc2VGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBVc2VyICdyZXNwb25zZScgZXZlbnQgbGlzdGVuZXJzIGNhbiBiZSBhZGRlZCBiZWZvcmUgb3VyIGxpc3RlbmVyLFxuICAgICAgICAgKiBmb3JjZSBvdXIgbGlzdGVuZXIgdG8gYmUgdGhlIGZpcnN0LCBzbyByZXNwb25zZSBlbWl0dGVyIGlzIGJvdW5kXG4gICAgICAgICAqIGJlZm9yZSBhbnkgdXNlciBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdC5wcmVwZW5kTGlzdGVuZXIoJ3Jlc3BvbnNlJywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gcmVzcG9uc2UoKScpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QubGlzdGVuZXJDb3VudCgncmVzcG9uc2UnKSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSkocmVzcG9uc2UsIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHJlc3BvbnNlQXR0cmlidXRlcyk7XG4gICAgICAgICAgICBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihvbGRNZXRyaWNBdHRyaWJ1dGVzLCAoMCwgdXRpbHNfMS5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSkocmVzcG9uc2VBdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDb25maWcoKS5yZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsUmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUuY2xpZW50LmNhcHR1cmVSZXF1ZXN0SGVhZGVycyhzcGFuLCBoZWFkZXIgPT4gcmVxdWVzdC5nZXRIZWFkZXIoaGVhZGVyKSk7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlLmNsaWVudC5jYXB0dXJlUmVzcG9uc2VIZWFkZXJzKHNwYW4sIGhlYWRlciA9PiByZXNwb25zZS5oZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIGVuZCgpJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5hYm9ydGVkICYmICFyZXNwb25zZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSB7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWhhdmVzIHNhbWUgZm9yIG5ldyBhbmQgb2xkIHNlbWNvbnZcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogKDAsIHV0aWxzXzEucGFyc2VSZXNwb25zZVN0YXR1cykoYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCByZXNwb25zZS5zdGF0dXNDb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRDb25maWcoKS5hcHBseUN1c3RvbUF0dHJpYnV0ZXNPblNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKHNwYW4sIHJlcXVlc3QsIHJlc3BvbnNlKSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5DTElFTlQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWpzL3B1bGwvMzYyNSNpc3N1ZWNvbW1lbnQtMTQ3NTY3MzUzM1xuICAgICAgICAgICAgaWYgKHNlbXZlci5sdChwcm9jZXNzLnZlcnNpb24sICcxNi4wLjAnKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdjbG9zZScsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2Uub24oZXZlbnRzXzEuZXJyb3JNb25pdG9yLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gZXJyb3IoKScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiByZXF1ZXN0IGNsb3NlKCknKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVzcG9uc2VGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5DTElFTlQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKGV2ZW50c18xLmVycm9yTW9uaXRvciwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gcmVxdWVzdCBlcnJvcigpJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGlhZy5kZWJ1ZygnaHR0cC5DbGllbnRSZXF1ZXN0IHJldHVybiByZXF1ZXN0Jyk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBfaW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaW5jb21pbmdSZXF1ZXN0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHRyYWNlcyByZXF1ZXN0IGV2ZW50c1xuICAgICAgICAgICAgaWYgKGV2ZW50ICE9PSAncmVxdWVzdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gYXJnc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmRlYnVnKGAke2NvbXBvbmVudH0gaW5zdHJ1bWVudGF0aW9uIGluY29taW5nUmVxdWVzdGApO1xuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkpLmlnbm9yZUluY29taW5nUmVxdWVzdEhvb2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCByZXF1ZXN0KTsgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5lcnJvcignY2F1Z2h0IGlnbm9yZUluY29taW5nUmVxdWVzdEhvb2sgZXJyb3I6ICcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aCgoMCwgY29yZV8xLnN1cHByZXNzVHJhY2luZykoYXBpXzEuY29udGV4dC5hY3RpdmUoKSksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQoYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzO1xuICAgICAgICAgICAgY29uc3Qgc3BhbkF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzKShyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc2VydmVyTmFtZTogaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnNlcnZlck5hbWUsXG4gICAgICAgICAgICAgICAgaG9va0F0dHJpYnV0ZXM6IGluc3RydW1lbnRhdGlvbi5fY2FsbFN0YXJ0U3Bhbkhvb2socmVxdWVzdCwgaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnN0YXJ0SW5jb21pbmdTcGFuSG9vayksXG4gICAgICAgICAgICAgICAgc2VtY29udlN0YWJpbGl0eTogaW5zdHJ1bWVudGF0aW9uLl9zZW1jb252U3RhYmlsaXR5LFxuICAgICAgICAgICAgfSwgaW5zdHJ1bWVudGF0aW9uLl9kaWFnKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlNFUlZFUixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZE1ldHJpY0F0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzKShzcGFuQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IG1ldGhvZCBhbmQgdXJsLnNjaGVtZSBhcmUgYm90aCByZXF1aXJlZCBzcGFuIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNvbnN0IHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV06IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfU0NIRU1FXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZWNvbW1lbmRlZCBpZiBhbmQgb25seSBpZiBvbmUgd2FzIHNlbnQsIHNhbWUgYXMgc3BhbiByZWNvbW1lbmRhdGlvblxuICAgICAgICAgICAgaWYgKHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dKSB7XG4gICAgICAgICAgICAgICAgc3RhYmxlTWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSA9XG4gICAgICAgICAgICAgICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRIdHRwU3BhbihtZXRob2QsIHNwYW5PcHRpb25zLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgcnBjTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogY29yZV8yLlJQQ1R5cGUuSFRUUCxcbiAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgoKDAsIGNvcmVfMi5zZXRSUENNZXRhZGF0YSkoYXBpXzEudHJhY2Uuc2V0U3BhbihjdHgsIHNwYW4pLCBycGNNZXRhZGF0YSksICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQoYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnJlcXVlc3RIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnJlc3BvbnNlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2NhbGxSZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2hlYWRlckNhcHR1cmUuc2VydmVyLmNhcHR1cmVSZXF1ZXN0SGVhZGVycyhzcGFuLCBoZWFkZXIgPT4gcmVxdWVzdC5oZWFkZXJzW2hlYWRlcl0pO1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyICdlcnJvcicsIG5vIGZ1cnRoZXIgZXZlbnRzIG90aGVyIHRoYW4gJ2Nsb3NlJyBzaG91bGQgYmUgZW1pdHRlZC5cbiAgICAgICAgICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fb25TZXJ2ZXJSZXNwb25zZUZpbmlzaChyZXF1ZXN0LCByZXNwb25zZSwgc3Bhbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihldmVudHNfMS5lcnJvck1vbml0b3IsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX29uU2VydmVyUmVzcG9uc2VFcnJvcihzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZXZlbnQsIC4uLmFyZ3NdKSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCBpbnN0cnVtZW50YXRpb24uX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX291dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG91dGdvaW5nUmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzVmFsaWRPcHRpb25zVHlwZSkob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW29wdGlvbnMsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgb3B0aW9ucyBpbnN0YW5jZW9mIHVybC5VUkwpXG4gICAgICAgICAgICAgICAgPyBhcmdzLnNoaWZ0KClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBpbnZhbGlkVXJsLCBvcHRpb25zUGFyc2VkIH0gPSAoMCwgdXRpbHNfMS5nZXRSZXF1ZXN0SW5mbykoaW5zdHJ1bWVudGF0aW9uLl9kaWFnLCBvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb2RlIDgncyBodHRwcyBtb2R1bGUgZGlyZWN0bHkgY2FsbCB0aGUgaHR0cCBvbmUgc28gdG8gYXZvaWQgY3JlYXRpbmdcbiAgICAgICAgICAgICAqIDIgc3BhbiBmb3IgdGhlIHNhbWUgcmVxdWVzdCB3ZSBuZWVkIHRvIGNoZWNrIHRoYXQgdGhlIHByb3RvY29sIGlzIGNvcnJlY3RcbiAgICAgICAgICAgICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjguMTcuMC9saWIvaHR0cHMuanMjTDI0NVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnaHR0cCcgJiZcbiAgICAgICAgICAgICAgICBzZW12ZXIubHQocHJvY2Vzcy52ZXJzaW9uLCAnOS4wLjAnKSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBpbnN0cnVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgLmdldENvbmZpZygpKS5pZ25vcmVPdXRnb2luZ1JlcXVlc3RIb29rKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgb3B0aW9uc1BhcnNlZCk7XG4gICAgICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmVycm9yKCdjYXVnaHQgaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vayBlcnJvcjogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW29wdGlvbnNQYXJzZWQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgaG9zdG5hbWUsIHBvcnQgfSA9ICgwLCB1dGlsc18xLmV4dHJhY3RIb3N0bmFtZUFuZFBvcnQpKG9wdGlvbnNQYXJzZWQpO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMpKG9wdGlvbnNQYXJzZWQsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICAgICAgICBob29rQXR0cmlidXRlczogaW5zdHJ1bWVudGF0aW9uLl9jYWxsU3RhcnRTcGFuSG9vayhvcHRpb25zUGFyc2VkLCBpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkuc3RhcnRPdXRnb2luZ1NwYW5Ib29rKSxcbiAgICAgICAgICAgIH0sIGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZE1ldHJpY0F0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzKShhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgbWV0aG9kLCBzZXJ2ZXIgYWRkcmVzcywgYW5kIHNlcnZlciBwb3J0IGFyZSBib3RoIHJlcXVpcmVkIHNwYW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgY29uc3Qgc3RhYmxlTWV0cmljQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdOiBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXTogYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdOiBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVxdWlyZW1lbnRcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID1cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvbW1lbmRlZCBpZiBhbmQgb25seSBpZiBvbmUgd2FzIHNlbnQsIHNhbWUgYXMgc3BhbiByZWNvbW1lbmRhdGlvblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0pIHtcbiAgICAgICAgICAgICAgICBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dID1cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLkNMSUVOVCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0SHR0cFNwYW4obWV0aG9kLCBzcGFuT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDb250ZXh0ID0gYXBpXzEuY29udGV4dC5hY3RpdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0gYXBpXzEudHJhY2Uuc2V0U3BhbihwYXJlbnRDb250ZXh0LCBzcGFuKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9uc1BhcnNlZC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5oZWFkZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgY29weSBvZiB0aGUgaGVhZGVycyBvYmplY3QgdG8gYXZvaWQgbXV0YXRpbmcgYW4gb2JqZWN0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxlciBtaWdodCBoYXZlIGEgcmVmZXJlbmNlIHRvLlxuICAgICAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnNQYXJzZWQuaGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QocmVxdWVzdENvbnRleHQsIG9wdGlvbnNQYXJzZWQuaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKHJlcXVlc3RDb250ZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBUaGUgcmVzcG9uc2UgY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCBiZWZvcmUgQ2xpZW50UmVxdWVzdCBpcyBib3VuZCxcbiAgICAgICAgICAgICAgICAgKiB0aHVzIGl0IGlzIG5lZWRlZCB0byBiaW5kIGl0IGJlZm9yZSB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGFwaV8xLmNvbnRleHQuYmluZChwYXJlbnRDb250ZXh0LCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSB1cmwgaXMgaW52YWxpZCwgdGhlcmUncyBubyBwb2ludCBpbiBpbmplY3RpbmcgY29udGV4dCBhcyBpdCB3aWxsIGZhaWwgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3NpbmcgaW4gd2hhdCB0aGUgdXNlciBwcm92aWRlZCB3aWxsIGdpdmUgdGhlIHVzZXIgYW4gZXJyb3IgdGhhdCBtYXRjaGVzIHdoYXQgdGhleSdkIHNlZSB3aXRob3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaW5zdHJ1bWVudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW29wdGlvbnNQYXJzZWQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgaW5zdHJ1bWVudGF0aW9uLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5DTElFTlQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5kZWJ1ZyhgJHtjb21wb25lbnR9IGluc3RydW1lbnRhdGlvbiBvdXRnb2luZ1JlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQocGFyZW50Q29udGV4dCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fdHJhY2VDbGllbnRSZXF1ZXN0KHJlcXVlc3QsIHNwYW4sIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX29uU2VydmVyUmVzcG9uc2VGaW5pc2gocmVxdWVzdCwgcmVzcG9uc2UsIHNwYW4sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UpKHJlcXVlc3QsIHJlc3BvbnNlLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgb2xkTWV0cmljQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24ob2xkTWV0cmljQXR0cmlidXRlcywgKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UpKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgc3RhYmxlTWV0cmljQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oc3RhYmxlTWV0cmljQXR0cmlidXRlcywgKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UpKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5zZXJ2ZXIuY2FwdHVyZVJlc3BvbnNlSGVhZGVycyhzcGFuLCBoZWFkZXIgPT4gcmVzcG9uc2UuZ2V0SGVhZGVyKGhlYWRlcikpO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykuc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6ICgwLCB1dGlsc18xLnBhcnNlUmVzcG9uc2VTdGF0dXMpKGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb3V0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXTtcbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7cmVxdWVzdC5tZXRob2QgfHwgJ0dFVCd9ICR7cm91dGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKSB7XG4gICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gdGhpcy5nZXRDb25maWcoKS5hcHBseUN1c3RvbUF0dHJpYnV0ZXNPblNwYW4oc3BhbiwgcmVxdWVzdCwgcmVzcG9uc2UpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuU0VSVkVSLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBfb25TZXJ2ZXJSZXNwb25zZUVycm9yKHNwYW4sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZXJyb3IpIHtcbiAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAvLyBUT0RPIGdldCBlcnJvciBhdHRyaWJ1dGVzIGZvciBtZXRyaWNzXG4gICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuU0VSVkVSLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBfc3RhcnRIdHRwU3BhbihuYW1lLCBvcHRpb25zLCBjdHggPSBhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIGEgcGFyZW50IGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJlc2VudCwgd2UgdXNlIGEgYE5vb3BTcGFuYCB0byBzdGlsbFxuICAgICAgICAgKiBwcm9wYWdhdGUgY29udGV4dCB3aXRob3V0IHJlY29yZGluZyBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlcXVpcmVQYXJlbnQgPSBvcHRpb25zLmtpbmQgPT09IGFwaV8xLlNwYW5LaW5kLkNMSUVOVFxuICAgICAgICAgICAgPyB0aGlzLmdldENvbmZpZygpLnJlcXVpcmVQYXJlbnRmb3JPdXRnb2luZ1NwYW5zXG4gICAgICAgICAgICA6IHRoaXMuZ2V0Q29uZmlnKCkucmVxdWlyZVBhcmVudGZvckluY29taW5nU3BhbnM7XG4gICAgICAgIGxldCBzcGFuO1xuICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IGFwaV8xLnRyYWNlLmdldFNwYW4oY3R4KTtcbiAgICAgICAgaWYgKHJlcXVpcmVQYXJlbnQgPT09IHRydWUgJiYgY3VycmVudFNwYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3BhbiA9IGFwaV8xLnRyYWNlLndyYXBTcGFuQ29udGV4dChhcGlfMS5JTlZBTElEX1NQQU5fQ09OVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxdWlyZVBhcmVudCA9PT0gdHJ1ZSAmJiAoY3VycmVudFNwYW4gPT09IG51bGwgfHwgY3VycmVudFNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTcGFuLnNwYW5Db250ZXh0KCkuaXNSZW1vdGUpKSB7XG4gICAgICAgICAgICBzcGFuID0gY3VycmVudFNwYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy50cmFjZXIuc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3Bhbk5vdEVuZGVkLmFkZChzcGFuKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIF9jbG9zZUh0dHBTcGFuKHNwYW4sIHNwYW5LaW5kLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zcGFuTm90RW5kZWQuaGFzKHNwYW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fc3Bhbk5vdEVuZGVkLmRlbGV0ZShzcGFuKTtcbiAgICAgICAgLy8gUmVjb3JkIG1ldHJpY3NcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSAoMCwgY29yZV8xLmhyVGltZVRvTWlsbGlzZWNvbmRzKSgoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShzdGFydFRpbWUsICgwLCBjb3JlXzEuaHJUaW1lKSgpKSk7XG4gICAgICAgIGlmIChzcGFuS2luZCA9PT0gYXBpXzEuU3BhbktpbmQuU0VSVkVSKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRTZXJ2ZXJEdXJhdGlvbihkdXJhdGlvbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BhbktpbmQgPT09IGFwaV8xLlNwYW5LaW5kLkNMSUVOVCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkQ2xpZW50RHVyYXRpb24oZHVyYXRpb24sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxsUmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlKSB7XG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB0aGlzLmdldENvbmZpZygpLnJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIF9jYWxsUmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCkge1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gdGhpcy5nZXRDb25maWcoKS5yZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0KSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICB9XG4gICAgX2NhbGxTdGFydFNwYW5Ib29rKHJlcXVlc3QsIGhvb2tGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaG9va0Z1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gaG9va0Z1bmMocmVxdWVzdCksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NyZWF0ZUhlYWRlckNhcHR1cmUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50OiB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZVJlcXVlc3RIZWFkZXJzOiAoMCwgdXRpbHNfMS5oZWFkZXJDYXB0dXJlKSgncmVxdWVzdCcsIChfYyA9IChfYiA9IChfYSA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcXVlc3RIZWFkZXJzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSksXG4gICAgICAgICAgICAgICAgY2FwdHVyZVJlc3BvbnNlSGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3Jlc3BvbnNlJywgKF9mID0gKF9lID0gKF9kID0gY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2xpZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVzcG9uc2VIZWFkZXJzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZVJlcXVlc3RIZWFkZXJzOiAoMCwgdXRpbHNfMS5oZWFkZXJDYXB0dXJlKSgncmVxdWVzdCcsIChfaiA9IChfaCA9IChfZyA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNlcnZlcikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnJlcXVlc3RIZWFkZXJzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBbXSksXG4gICAgICAgICAgICAgICAgY2FwdHVyZVJlc3BvbnNlSGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3Jlc3BvbnNlJywgKF9tID0gKF9sID0gKF9rID0gY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suc2VydmVyKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wucmVzcG9uc2VIZWFkZXJzKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiBbXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cEluc3RydW1lbnRhdGlvbiA9IEh0dHBJbnN0cnVtZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\n");

/***/ }),

/***/ "(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\nvar http_1 = __webpack_require__(/*! ./http */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\");\nObject.defineProperty(exports, \"HttpInstrumentation\", ({ enumerable: true, get: function () { return http_1.HttpInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQywrTEFBUTtBQUM3Qix1REFBc0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDcEkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmFraGFyL0RvY3VtZW50cy9vcGVuc19zb3VyY2VfY29udHJpYnV0aW9uXzIvbGlhbS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cEluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbnZhciBodHRwXzEgPSByZXF1aXJlKFwiLi9odHRwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cEluc3RydW1lbnRhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cF8xLkh0dHBJbnN0cnVtZW50YXRpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js\n");

/***/ }),

/***/ "(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js ***!
  \***************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.headerCapture = exports.getIncomingStableRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getRemoteClientAddress = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst AttributeNames_1 = __webpack_require__(/*! ./enums/AttributeNames */ \"(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\");\nconst forwardedParse = __webpack_require__(/*! forwarded-parse */ \"(instrument)/../../../node_modules/.pnpm/forwarded-parse@2.1.2/node_modules/forwarded-parse/index.js\");\n/**\n * Get an absolute url\n */\nconst getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = 'http:') => {\n    const reqUrlObject = requestUrl || {};\n    const protocol = reqUrlObject.protocol || fallbackProtocol;\n    const port = (reqUrlObject.port || '').toString();\n    const path = reqUrlObject.path || '/';\n    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || 'localhost';\n    // if there is no port in host and there is a port\n    // it should be displayed if it's not 80 and 443 (default ports)\n    if (host.indexOf(':') === -1 &&\n        port &&\n        port !== '80' &&\n        port !== '443') {\n        host += `:${port}`;\n    }\n    return `${protocol}//${host}${path}`;\n};\nexports.getAbsoluteUrl = getAbsoluteUrl;\n/**\n * Parse status code from HTTP response. [More details](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-http.md#status)\n */\nconst parseResponseStatus = (kind, statusCode) => {\n    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;\n    // 1xx, 2xx, 3xx are OK on client and server\n    // 4xx is OK on server\n    if (statusCode && statusCode >= 100 && statusCode < upperBound) {\n        return api_1.SpanStatusCode.UNSET;\n    }\n    // All other codes are error\n    return api_1.SpanStatusCode.ERROR;\n};\nexports.parseResponseStatus = parseResponseStatus;\n/**\n * Check whether the given obj match pattern\n * @param constant e.g URL of request\n * @param pattern Match pattern\n */\nconst satisfiesPattern = (constant, pattern) => {\n    if (typeof pattern === 'string') {\n        return pattern === constant;\n    }\n    else if (pattern instanceof RegExp) {\n        return pattern.test(constant);\n    }\n    else if (typeof pattern === 'function') {\n        return pattern(constant);\n    }\n    else {\n        throw new TypeError('Pattern is in unsupported datatype');\n    }\n};\nexports.satisfiesPattern = satisfiesPattern;\n/**\n * Sets the span with the error passed in params\n * @param {Span} span the span that need to be set\n * @param {Error} error error that will be set to span\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst setSpanWithError = (span, error, semconvStability) => {\n    const message = error.message;\n    if ((semconvStability & 2 /* OLD */) === 2 /* OLD */) {\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);\n    }\n    if ((semconvStability & 1 /* STABLE */) ===\n        1 /* STABLE */) {\n        span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);\n    }\n    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });\n    span.recordException(error);\n};\nexports.setSpanWithError = setSpanWithError;\n/**\n * Adds attributes for request content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Request object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n */\nconst setRequestContentLengthAttribute = (request, attributes) => {\n    const length = getContentLength(request.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(request.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;\n/**\n * Adds attributes for response content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Response object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n *\n * @deprecated this is for an older version of semconv. It is retained for compatibility using OTEL_SEMCONV_STABILITY_OPT_IN\n */\nconst setResponseContentLengthAttribute = (response, attributes) => {\n    const length = getContentLength(response.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(response.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;\nfunction getContentLength(headers) {\n    const contentLengthHeader = headers['content-length'];\n    if (contentLengthHeader === undefined)\n        return null;\n    const contentLength = parseInt(contentLengthHeader, 10);\n    if (isNaN(contentLength))\n        return null;\n    return contentLength;\n}\nconst isCompressed = (headers) => {\n    const encoding = headers['content-encoding'];\n    return !!encoding && encoding !== 'identity';\n};\nexports.isCompressed = isCompressed;\n/**\n * Mimics Node.js conversion of URL strings to RequestOptions expected by\n * `http.request` and `https.request` APIs.\n *\n * See https://github.com/nodejs/node/blob/2505e217bba05fc581b572c685c5cf280a16c5a3/lib/internal/url.js#L1415-L1437\n *\n * @param stringUrl\n * @throws TypeError if the URL is not valid.\n */\nfunction stringUrlToHttpOptions(stringUrl) {\n    // This is heavily inspired by Node.js handling of the same situation, trying\n    // to follow it as closely as possible while keeping in mind that we only\n    // deal with string URLs, not URL objects.\n    const { hostname, pathname, port, username, password, search, protocol, hash, href, origin, host, } = new URL(stringUrl);\n    const options = {\n        protocol: protocol,\n        hostname: hostname && hostname[0] === '[' ? hostname.slice(1, -1) : hostname,\n        hash: hash,\n        search: search,\n        pathname: pathname,\n        path: `${pathname || ''}${search || ''}`,\n        href: href,\n        origin: origin,\n        host: host,\n    };\n    if (port !== '') {\n        options.port = Number(port);\n    }\n    if (username || password) {\n        options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n    }\n    return options;\n}\n/**\n * Makes sure options is an url object\n * return an object with default value and parsed options\n * @param logger component logger\n * @param options original options for the request\n * @param [extraOptions] additional options for the request\n */\nconst getRequestInfo = (logger, options, extraOptions) => {\n    let pathname;\n    let origin;\n    let optionsParsed;\n    let invalidUrl = false;\n    if (typeof options === 'string') {\n        try {\n            const convertedOptions = stringUrlToHttpOptions(options);\n            optionsParsed = convertedOptions;\n            pathname = convertedOptions.pathname || '/';\n        }\n        catch (e) {\n            invalidUrl = true;\n            logger.verbose('Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:', e);\n            // for backward compatibility with how url.parse() behaved.\n            optionsParsed = {\n                path: options,\n            };\n            pathname = optionsParsed.path || '/';\n        }\n        origin = `${optionsParsed.protocol || 'http:'}//${optionsParsed.host}`;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else if (options instanceof url.URL) {\n        optionsParsed = {\n            protocol: options.protocol,\n            hostname: typeof options.hostname === 'string' && options.hostname.startsWith('[')\n                ? options.hostname.slice(1, -1)\n                : options.hostname,\n            path: `${options.pathname || ''}${options.search || ''}`,\n        };\n        if (options.port !== '') {\n            optionsParsed.port = Number(options.port);\n        }\n        if (options.username || options.password) {\n            optionsParsed.auth = `${options.username}:${options.password}`;\n        }\n        pathname = options.pathname;\n        origin = options.origin;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else {\n        optionsParsed = Object.assign({ protocol: options.host ? 'http:' : undefined }, options);\n        const hostname = optionsParsed.host ||\n            (optionsParsed.port != null\n                ? `${optionsParsed.hostname}${optionsParsed.port}`\n                : optionsParsed.hostname);\n        origin = `${optionsParsed.protocol || 'http:'}//${hostname}`;\n        pathname = options.pathname;\n        if (!pathname && optionsParsed.path) {\n            try {\n                const parsedUrl = new URL(optionsParsed.path, origin);\n                pathname = parsedUrl.pathname || '/';\n            }\n            catch (e) {\n                pathname = '/';\n            }\n        }\n    }\n    // some packages return method in lowercase..\n    // ensure upperCase for consistency\n    const method = optionsParsed.method\n        ? optionsParsed.method.toUpperCase()\n        : 'GET';\n    return { origin, pathname, method, optionsParsed, invalidUrl };\n};\nexports.getRequestInfo = getRequestInfo;\n/**\n * Makes sure options is of type string or object\n * @param options for the request\n */\nconst isValidOptionsType = (options) => {\n    if (!options) {\n        return false;\n    }\n    const type = typeof options;\n    return type === 'string' || (type === 'object' && !Array.isArray(options));\n};\nexports.isValidOptionsType = isValidOptionsType;\nconst extractHostnameAndPort = (requestOptions) => {\n    var _a;\n    if (requestOptions.hostname && requestOptions.port) {\n        return { hostname: requestOptions.hostname, port: requestOptions.port };\n    }\n    const matches = ((_a = requestOptions.host) === null || _a === void 0 ? void 0 : _a.match(/^([^:/ ]+)(:\\d{1,5})?/)) || null;\n    const hostname = requestOptions.hostname || (matches === null ? 'localhost' : matches[1]);\n    let port = requestOptions.port;\n    if (!port) {\n        if (matches && matches[2]) {\n            // remove the leading \":\". The extracted port would be something like \":8080\"\n            port = matches[2].substring(1);\n        }\n        else {\n            port = requestOptions.protocol === 'https:' ? '443' : '80';\n        }\n    }\n    return { hostname, port };\n};\nexports.extractHostnameAndPort = extractHostnameAndPort;\n/**\n * Returns outgoing request attributes scoped to the options passed to the request\n * @param {ParsedRequestOptions} requestOptions the same options used to make the request\n * @param {{ component: string, hostname: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributes = (requestOptions, options, semconvStability) => {\n    var _a, _b;\n    const hostname = options.hostname;\n    const port = options.port;\n    const method = (_a = requestOptions.method) !== null && _a !== void 0 ? _a : 'GET';\n    const normalizedMethod = normalizeMethod(method);\n    const headers = requestOptions.headers || {};\n    const userAgent = headers['user-agent'];\n    const urlFull = (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`);\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: urlFull,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || '/',\n        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_b = headers.host) !== null && _b !== void 0 ? _b : `${hostname}:${port}`,\n    };\n    const newAttributes = {\n        // Required attributes\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname,\n        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),\n        [semantic_conventions_1.ATTR_URL_FULL]: urlFull,\n        // leaving out protocol version, it is not yet negotiated\n        // leaving out protocol name, it is only required when protocol version is set\n        // retries and redirects not supported\n        // Opt-in attributes left off for now\n    };\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;\n/**\n * Returns outgoing request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributes = (spanAttributes) => {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];\n    //TODO: http.url attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;\n/**\n * Returns attributes related to the kind of HTTP protocol used\n * @param {string} [kind] Kind of HTTP protocol used: \"1.0\", \"1.1\", \"2\", \"SPDY\" or \"QUIC\".\n */\nconst setAttributesFromHttpKind = (kind, attributes) => {\n    if (kind) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;\n        if (kind.toUpperCase() !== 'QUIC') {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;\n        }\n        else {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;\n        }\n    }\n};\nexports.setAttributesFromHttpKind = setAttributesFromHttpKind;\n/**\n * Returns outgoing request attributes scoped to the response data\n * @param {IncomingMessage} response the response object\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributesOnResponse = (response, semconvStability) => {\n    const { statusCode, statusMessage, httpVersion, socket } = response;\n    const oldAttributes = {};\n    const stableAttributes = {};\n    if (statusCode != null) {\n        stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;\n    }\n    if (socket) {\n        const { remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n        // Recommended\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;\n    }\n    (0, exports.setResponseContentLengthAttribute)(response, oldAttributes);\n    if (statusCode) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n        oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    }\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return stableAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, stableAttributes);\n};\nexports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;\n/**\n * Returns outgoing request Metric attributes scoped to the response data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) => {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;\nfunction parseHostHeader(hostHeader, proto) {\n    const parts = hostHeader.split(':');\n    // no semicolon implies ipv4 dotted syntax or host name without port\n    // x.x.x.x\n    // example.com\n    if (parts.length === 1) {\n        if (proto === 'http') {\n            return { host: parts[0], port: '80' };\n        }\n        if (proto === 'https') {\n            return { host: parts[0], port: '443' };\n        }\n        return { host: parts[0] };\n    }\n    // single semicolon implies ipv4 dotted syntax or host name with port\n    // x.x.x.x:yyyy\n    // example.com:yyyy\n    if (parts.length === 2) {\n        return {\n            host: parts[0],\n            port: parts[1],\n        };\n    }\n    // more than 2 parts implies ipv6 syntax with multiple colons\n    // [x:x:x:x:x:x:x:x]\n    // [x:x:x:x:x:x:x:x]:yyyy\n    if (parts[0].startsWith('[')) {\n        if (parts[parts.length - 1].endsWith(']')) {\n            if (proto === 'http') {\n                return { host: hostHeader, port: '80' };\n            }\n            if (proto === 'https') {\n                return { host: hostHeader, port: '443' };\n            }\n        }\n        else if (parts[parts.length - 2].endsWith(']')) {\n            return {\n                host: parts.slice(0, -1).join(':'),\n                port: parts[parts.length - 1],\n            };\n        }\n    }\n    // if nothing above matches just return the host header\n    return { host: hostHeader };\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getServerAddress(request, component) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.host) {\n                return parseHostHeader(entry.host, entry.proto);\n            }\n        }\n    }\n    const xForwardedHost = request.headers['x-forwarded-host'];\n    if (typeof xForwardedHost === 'string') {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost);\n    }\n    else if (Array.isArray(xForwardedHost) &&\n        typeof xForwardedHost[0] === 'string' &&\n        xForwardedHost[0].length > 0) {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost[0]);\n    }\n    const host = request.headers['host'];\n    if (typeof host === 'string' && host.length > 0) {\n        return parseHostHeader(host, component);\n    }\n    return null;\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getRemoteClientAddress(request) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.for) {\n                return entry.for;\n            }\n        }\n    }\n    const xForwardedFor = request.headers['x-forwarded-for'];\n    if (typeof xForwardedFor === 'string') {\n        return xForwardedFor;\n    }\n    else if (Array.isArray(xForwardedFor)) {\n        return xForwardedFor[0];\n    }\n    const remote = request.socket.remoteAddress;\n    if (remote) {\n        return remote;\n    }\n    return null;\n}\nexports.getRemoteClientAddress = getRemoteClientAddress;\nfunction getInfoFromIncomingMessage(component, request, logger) {\n    var _a, _b;\n    try {\n        if (request.headers.host) {\n            return new URL((_a = request.url) !== null && _a !== void 0 ? _a : '/', `${component}://${request.headers.host}`);\n        }\n        else {\n            const unsafeParsedUrl = new URL((_b = request.url) !== null && _b !== void 0 ? _b : '/', \n            // using localhost as a workaround to still use the URL constructor for parsing\n            `${component}://localhost`);\n            // since we use localhost as a workaround, ensure we hide the rest of the properties to avoid\n            // our workaround leaking though.\n            return {\n                pathname: unsafeParsedUrl.pathname,\n                search: unsafeParsedUrl.search,\n                toString: function () {\n                    // we cannot use the result of unsafeParsedUrl.toString as it's potentially wrong.\n                    return unsafeParsedUrl.pathname + unsafeParsedUrl.search;\n                },\n            };\n        }\n    }\n    catch (e) {\n        // something is wrong, use undefined - this *should* never happen, logging\n        // for troubleshooting in case it does happen.\n        logger.verbose('Unable to get URL from request', e);\n        return {};\n    }\n}\n/**\n * Returns incoming request attributes scoped to the request data\n * @param {IncomingMessage} request the request object\n * @param {{ component: string, serverName?: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getIncomingRequestAttributes = (request, options, logger) => {\n    const headers = request.headers;\n    const userAgent = headers['user-agent'];\n    const ips = headers['x-forwarded-for'];\n    const httpVersion = request.httpVersion;\n    const host = headers.host;\n    const hostname = (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, '$1')) || 'localhost';\n    const method = request.method;\n    const normalizedMethod = normalizeMethod(method);\n    const serverAddress = getServerAddress(request, options.component);\n    const serverName = options.serverName;\n    const remoteClientAddress = getRemoteClientAddress(request);\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.host,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,\n        [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,\n        [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent,\n    };\n    const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger);\n    if ((parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) != null) {\n        newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;\n    }\n    if (remoteClientAddress != null) {\n        newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress;\n    }\n    if ((serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port) != null) {\n        newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);\n    }\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: parsedUrl.toString(),\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,\n        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component,\n    };\n    if (typeof ips === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(',')[0];\n    }\n    if (typeof serverName === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;\n    }\n    if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] =\n            (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) + (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.search) || '/';\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    (0, exports.setRequestContentLengthAttribute)(request, oldAttributes);\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (options.semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getIncomingRequestAttributes = getIncomingRequestAttributes;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n * @param {{ component: string }} options used to pass data needed to create attributes\n */\nconst getIncomingRequestMetricAttributes = (spanAttributes) => {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    //TODO: http.target attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;\n/**\n * Returns incoming request attributes scoped to the response data\n * @param {(ServerResponse & { socket: Socket; })} response the response object\n */\nconst getIncomingRequestAttributesOnResponse = (request, response, semconvStability) => {\n    // take socket from the request,\n    // since it may be detached from the response object in keep-alive mode\n    const { socket } = request;\n    const { statusCode, statusMessage } = response;\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,\n    };\n    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());\n    const oldAttributes = {};\n    if (socket) {\n        const { localAddress, localPort, remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n    }\n    oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n    oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP && rpcMetadata.route !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;\n        newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return newAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, newAttributes);\n};\nexports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getIncomingRequestMetricAttributesOnResponse = (spanAttributes) => {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];\n    if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;\nconst getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) => {\n    const metricAttributes = {};\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    // required if and only if one was sent, same as span requirement\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n            spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;\nfunction headerCapture(type, headers) {\n    const normalizedHeaders = new Map();\n    for (let i = 0, len = headers.length; i < len; i++) {\n        const capturedHeader = headers[i].toLowerCase();\n        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, '_'));\n    }\n    return (span, getHeader) => {\n        for (const capturedHeader of normalizedHeaders.keys()) {\n            const value = getHeader(capturedHeader);\n            if (value === undefined) {\n                continue;\n            }\n            const normalizedHeader = normalizedHeaders.get(capturedHeader);\n            const key = `http.${type}.header.${normalizedHeader}`;\n            if (typeof value === 'string') {\n                span.setAttribute(key, [value]);\n            }\n            else if (Array.isArray(value)) {\n                span.setAttribute(key, value);\n            }\n            else {\n                span.setAttribute(key, [value]);\n            }\n        }\n    };\n}\nexports.headerCapture = headerCapture;\nconst KNOWN_METHODS = new Set([\n    // methods from https://www.rfc-editor.org/rfc/rfc9110.html#name-methods\n    'GET',\n    'HEAD',\n    'POST',\n    'PUT',\n    'DELETE',\n    'CONNECT',\n    'OPTIONS',\n    'TRACE',\n    // PATCH from https://www.rfc-editor.org/rfc/rfc5789.html\n    'PATCH',\n]);\nfunction normalizeMethod(method) {\n    if (method == null) {\n        return 'GET';\n    }\n    const upper = method.toUpperCase();\n    if (KNOWN_METHODS.has(upper)) {\n        return upper;\n    }\n    return '_OTHER';\n}\nfunction parseForwardedHeader(header) {\n    try {\n        return forwardedParse(header);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsMERBQTBELEdBQUcsb0RBQW9ELEdBQUcsOENBQThDLEdBQUcsMENBQTBDLEdBQUcsb0NBQW9DLEdBQUcsOEJBQThCLEdBQUcsb0RBQW9ELEdBQUcsOENBQThDLEdBQUcsaUNBQWlDLEdBQUcsMENBQTBDLEdBQUcsb0NBQW9DLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcseUNBQXlDLEdBQUcsd0NBQXdDLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCO0FBQ2owQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0pBQW9CO0FBQzFDLCtCQUErQixtQkFBTyxDQUFDLG9NQUFxQztBQUM1RSxlQUFlLG1CQUFPLENBQUMsNktBQXFCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6Qix5QkFBeUIsbUJBQU8sQ0FBQywrTkFBd0I7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsNkhBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsY0FBYyxTQUFTLElBQUksS0FBSyxFQUFFLEtBQUs7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcHJha2hhci9Eb2N1bWVudHMvb3BlbnNfc291cmNlX2NvbnRyaWJ1dGlvbl8yL2xpYW0vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGVhZGVyQ2FwdHVyZSA9IGV4cG9ydHMuZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGV4cG9ydHMuZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcyA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kID0gZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzID0gZXhwb3J0cy5leHRyYWN0SG9zdG5hbWVBbmRQb3J0ID0gZXhwb3J0cy5pc1ZhbGlkT3B0aW9uc1R5cGUgPSBleHBvcnRzLmdldFJlcXVlc3RJbmZvID0gZXhwb3J0cy5pc0NvbXByZXNzZWQgPSBleHBvcnRzLnNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZSA9IGV4cG9ydHMuc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSBleHBvcnRzLnNldFNwYW5XaXRoRXJyb3IgPSBleHBvcnRzLnNhdGlzZmllc1BhdHRlcm4gPSBleHBvcnRzLnBhcnNlUmVzcG9uc2VTdGF0dXMgPSBleHBvcnRzLmdldEFic29sdXRlVXJsID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBBdHRyaWJ1dGVOYW1lc18xID0gcmVxdWlyZShcIi4vZW51bXMvQXR0cmlidXRlTmFtZXNcIik7XG5jb25zdCBmb3J3YXJkZWRQYXJzZSA9IHJlcXVpcmUoXCJmb3J3YXJkZWQtcGFyc2VcIik7XG4vKipcbiAqIEdldCBhbiBhYnNvbHV0ZSB1cmxcbiAqL1xuY29uc3QgZ2V0QWJzb2x1dGVVcmwgPSAocmVxdWVzdFVybCwgaGVhZGVycywgZmFsbGJhY2tQcm90b2NvbCA9ICdodHRwOicpID0+IHtcbiAgICBjb25zdCByZXFVcmxPYmplY3QgPSByZXF1ZXN0VXJsIHx8IHt9O1xuICAgIGNvbnN0IHByb3RvY29sID0gcmVxVXJsT2JqZWN0LnByb3RvY29sIHx8IGZhbGxiYWNrUHJvdG9jb2w7XG4gICAgY29uc3QgcG9ydCA9IChyZXFVcmxPYmplY3QucG9ydCB8fCAnJykudG9TdHJpbmcoKTtcbiAgICBjb25zdCBwYXRoID0gcmVxVXJsT2JqZWN0LnBhdGggfHwgJy8nO1xuICAgIGxldCBob3N0ID0gcmVxVXJsT2JqZWN0Lmhvc3QgfHwgcmVxVXJsT2JqZWN0Lmhvc3RuYW1lIHx8IGhlYWRlcnMuaG9zdCB8fCAnbG9jYWxob3N0JztcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBwb3J0IGluIGhvc3QgYW5kIHRoZXJlIGlzIGEgcG9ydFxuICAgIC8vIGl0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaWYgaXQncyBub3QgODAgYW5kIDQ0MyAoZGVmYXVsdCBwb3J0cylcbiAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xICYmXG4gICAgICAgIHBvcnQgJiZcbiAgICAgICAgcG9ydCAhPT0gJzgwJyAmJlxuICAgICAgICBwb3J0ICE9PSAnNDQzJykge1xuICAgICAgICBob3N0ICs9IGA6JHtwb3J0fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdH0ke3BhdGh9YDtcbn07XG5leHBvcnRzLmdldEFic29sdXRlVXJsID0gZ2V0QWJzb2x1dGVVcmw7XG4vKipcbiAqIFBhcnNlIHN0YXR1cyBjb2RlIGZyb20gSFRUUCByZXNwb25zZS4gW01vcmUgZGV0YWlsc10oaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktc3BlY2lmaWNhdGlvbi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uL2RhdGEtaHR0cC5tZCNzdGF0dXMpXG4gKi9cbmNvbnN0IHBhcnNlUmVzcG9uc2VTdGF0dXMgPSAoa2luZCwgc3RhdHVzQ29kZSkgPT4ge1xuICAgIGNvbnN0IHVwcGVyQm91bmQgPSBraW5kID09PSBhcGlfMS5TcGFuS2luZC5DTElFTlQgPyA0MDAgOiA1MDA7XG4gICAgLy8gMXh4LCAyeHgsIDN4eCBhcmUgT0sgb24gY2xpZW50IGFuZCBzZXJ2ZXJcbiAgICAvLyA0eHggaXMgT0sgb24gc2VydmVyXG4gICAgaWYgKHN0YXR1c0NvZGUgJiYgc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8IHVwcGVyQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGFwaV8xLlNwYW5TdGF0dXNDb2RlLlVOU0VUO1xuICAgIH1cbiAgICAvLyBBbGwgb3RoZXIgY29kZXMgYXJlIGVycm9yXG4gICAgcmV0dXJuIGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SO1xufTtcbmV4cG9ydHMucGFyc2VSZXNwb25zZVN0YXR1cyA9IHBhcnNlUmVzcG9uc2VTdGF0dXM7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG9iaiBtYXRjaCBwYXR0ZXJuXG4gKiBAcGFyYW0gY29uc3RhbnQgZS5nIFVSTCBvZiByZXF1ZXN0XG4gKiBAcGFyYW0gcGF0dGVybiBNYXRjaCBwYXR0ZXJuXG4gKi9cbmNvbnN0IHNhdGlzZmllc1BhdHRlcm4gPSAoY29uc3RhbnQsIHBhdHRlcm4pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID09PSBjb25zdGFudDtcbiAgICB9XG4gICAgZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KGNvbnN0YW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4oY29uc3RhbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0dGVybiBpcyBpbiB1bnN1cHBvcnRlZCBkYXRhdHlwZScpO1xuICAgIH1cbn07XG5leHBvcnRzLnNhdGlzZmllc1BhdHRlcm4gPSBzYXRpc2ZpZXNQYXR0ZXJuO1xuLyoqXG4gKiBTZXRzIHRoZSBzcGFuIHdpdGggdGhlIGVycm9yIHBhc3NlZCBpbiBwYXJhbXNcbiAqIEBwYXJhbSB7U3Bhbn0gc3BhbiB0aGUgc3BhbiB0aGF0IG5lZWQgdG8gYmUgc2V0XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBlcnJvciB0aGF0IHdpbGwgYmUgc2V0IHRvIHNwYW5cbiAqIEBwYXJhbSB7U2VtY29udlN0YWJpbGl0eX0gc2VtY29udlN0YWJpbGl0eSBkZXRlcm1pbmVzIHdoaWNoIHNlbWNvbnYgdmVyc2lvbiB0byB1c2VcbiAqL1xuY29uc3Qgc2V0U3BhbldpdGhFcnJvciA9IChzcGFuLCBlcnJvciwgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmICgoc2VtY29udlN0YWJpbGl0eSAmIDIgLyogT0xEICovKSA9PT0gMiAvKiBPTEQgKi8pIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoQXR0cmlidXRlTmFtZXNfMS5BdHRyaWJ1dGVOYW1lcy5IVFRQX0VSUk9SX05BTUUsIGVycm9yLm5hbWUpO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShBdHRyaWJ1dGVOYW1lc18xLkF0dHJpYnV0ZU5hbWVzLkhUVFBfRVJST1JfTUVTU0FHRSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICgoc2VtY29udlN0YWJpbGl0eSAmIDEgLyogU1RBQkxFICovKSA9PT1cbiAgICAgICAgMSAvKiBTVEFCTEUgKi8pIHtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0VSUk9SX1RZUEUsIGVycm9yLm5hbWUpO1xuICAgIH1cbiAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLCBtZXNzYWdlIH0pO1xuICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycm9yKTtcbn07XG5leHBvcnRzLnNldFNwYW5XaXRoRXJyb3IgPSBzZXRTcGFuV2l0aEVycm9yO1xuLyoqXG4gKiBBZGRzIGF0dHJpYnV0ZXMgZm9yIHJlcXVlc3QgY29udGVudC1sZW5ndGggYW5kIGNvbnRlbnQtZW5jb2RpbmcgSFRUUCBoZWFkZXJzXG4gKiBAcGFyYW0geyBJbmNvbWluZ01lc3NhZ2UgfSBSZXF1ZXN0IG9iamVjdCB3aG9zZSBoZWFkZXJzIHdpbGwgYmUgYW5hbHl6ZWRcbiAqIEBwYXJhbSB7IEF0dHJpYnV0ZXMgfSBBdHRyaWJ1dGVzIG9iamVjdCB0byBiZSBtb2RpZmllZFxuICovXG5jb25zdCBzZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZSA9IChyZXF1ZXN0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0Q29udGVudExlbmd0aChyZXF1ZXN0LmhlYWRlcnMpO1xuICAgIGlmIChsZW5ndGggPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNDb21wcmVzc2VkKShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhdID0gbGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRURdID0gbGVuZ3RoO1xuICAgIH1cbn07XG5leHBvcnRzLnNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGU7XG4vKipcbiAqIEFkZHMgYXR0cmlidXRlcyBmb3IgcmVzcG9uc2UgY29udGVudC1sZW5ndGggYW5kIGNvbnRlbnQtZW5jb2RpbmcgSFRUUCBoZWFkZXJzXG4gKiBAcGFyYW0geyBJbmNvbWluZ01lc3NhZ2UgfSBSZXNwb25zZSBvYmplY3Qgd2hvc2UgaGVhZGVycyB3aWxsIGJlIGFuYWx5emVkXG4gKiBAcGFyYW0geyBBdHRyaWJ1dGVzIH0gQXR0cmlidXRlcyBvYmplY3QgdG8gYmUgbW9kaWZpZWRcbiAqXG4gKiBAZGVwcmVjYXRlZCB0aGlzIGlzIGZvciBhbiBvbGRlciB2ZXJzaW9uIG9mIHNlbWNvbnYuIEl0IGlzIHJldGFpbmVkIGZvciBjb21wYXRpYmlsaXR5IHVzaW5nIE9URUxfU0VNQ09OVl9TVEFCSUxJVFlfT1BUX0lOXG4gKi9cbmNvbnN0IHNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZSA9IChyZXNwb25zZSwgYXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldENvbnRlbnRMZW5ndGgocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICgoMCwgZXhwb3J0cy5pc0NvbXByZXNzZWQpKHJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIXSA9IGxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRF0gPSBsZW5ndGg7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlO1xuZnVuY3Rpb24gZ2V0Q29udGVudExlbmd0aChoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKTtcbiAgICBpZiAoaXNOYU4oY29udGVudExlbmd0aCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBjb250ZW50TGVuZ3RoO1xufVxuY29uc3QgaXNDb21wcmVzc2VkID0gKGhlYWRlcnMpID0+IHtcbiAgICBjb25zdCBlbmNvZGluZyA9IGhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICByZXR1cm4gISFlbmNvZGluZyAmJiBlbmNvZGluZyAhPT0gJ2lkZW50aXR5Jztcbn07XG5leHBvcnRzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbi8qKlxuICogTWltaWNzIE5vZGUuanMgY29udmVyc2lvbiBvZiBVUkwgc3RyaW5ncyB0byBSZXF1ZXN0T3B0aW9ucyBleHBlY3RlZCBieVxuICogYGh0dHAucmVxdWVzdGAgYW5kIGBodHRwcy5yZXF1ZXN0YCBBUElzLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi8yNTA1ZTIxN2JiYTA1ZmM1ODFiNTcyYzY4NWM1Y2YyODBhMTZjNWEzL2xpYi9pbnRlcm5hbC91cmwuanMjTDE0MTUtTDE0MzdcbiAqXG4gKiBAcGFyYW0gc3RyaW5nVXJsXG4gKiBAdGhyb3dzIFR5cGVFcnJvciBpZiB0aGUgVVJMIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVXJsVG9IdHRwT3B0aW9ucyhzdHJpbmdVcmwpIHtcbiAgICAvLyBUaGlzIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnkgTm9kZS5qcyBoYW5kbGluZyBvZiB0aGUgc2FtZSBzaXR1YXRpb24sIHRyeWluZ1xuICAgIC8vIHRvIGZvbGxvdyBpdCBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHdoaWxlIGtlZXBpbmcgaW4gbWluZCB0aGF0IHdlIG9ubHlcbiAgICAvLyBkZWFsIHdpdGggc3RyaW5nIFVSTHMsIG5vdCBVUkwgb2JqZWN0cy5cbiAgICBjb25zdCB7IGhvc3RuYW1lLCBwYXRobmFtZSwgcG9ydCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBzZWFyY2gsIHByb3RvY29sLCBoYXNoLCBocmVmLCBvcmlnaW4sIGhvc3QsIH0gPSBuZXcgVVJMKHN0cmluZ1VybCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgICAgICBob3N0bmFtZTogaG9zdG5hbWUgJiYgaG9zdG5hbWVbMF0gPT09ICdbJyA/IGhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IGhvc3RuYW1lLFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICBwYXRoOiBgJHtwYXRobmFtZSB8fCAnJ30ke3NlYXJjaCB8fCAnJ31gLFxuICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgaG9zdDogaG9zdCxcbiAgICB9O1xuICAgIGlmIChwb3J0ICE9PSAnJykge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIocG9ydCk7XG4gICAgfVxuICAgIGlmICh1c2VybmFtZSB8fCBwYXNzd29yZCkge1xuICAgICAgICBvcHRpb25zLmF1dGggPSBgJHtkZWNvZGVVUklDb21wb25lbnQodXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudChwYXNzd29yZCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIE1ha2VzIHN1cmUgb3B0aW9ucyBpcyBhbiB1cmwgb2JqZWN0XG4gKiByZXR1cm4gYW4gb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZSBhbmQgcGFyc2VkIG9wdGlvbnNcbiAqIEBwYXJhbSBsb2dnZXIgY29tcG9uZW50IGxvZ2dlclxuICogQHBhcmFtIG9wdGlvbnMgb3JpZ2luYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSBbZXh0cmFPcHRpb25zXSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gKi9cbmNvbnN0IGdldFJlcXVlc3RJbmZvID0gKGxvZ2dlciwgb3B0aW9ucywgZXh0cmFPcHRpb25zKSA9PiB7XG4gICAgbGV0IHBhdGhuYW1lO1xuICAgIGxldCBvcmlnaW47XG4gICAgbGV0IG9wdGlvbnNQYXJzZWQ7XG4gICAgbGV0IGludmFsaWRVcmwgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRPcHRpb25zID0gc3RyaW5nVXJsVG9IdHRwT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQgPSBjb252ZXJ0ZWRPcHRpb25zO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBjb252ZXJ0ZWRPcHRpb25zLnBhdGhuYW1lIHx8ICcvJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaW52YWxpZFVybCA9IHRydWU7XG4gICAgICAgICAgICBsb2dnZXIudmVyYm9zZSgnVW5hYmxlIHRvIHBhcnNlIFVSTCBwcm92aWRlZCB0byBIVFRQIHJlcXVlc3QsIHVzaW5nIGZhbGxiYWNrIHRvIGRldGVybWluZSBwYXRoLiBPcmlnaW5hbCBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggaG93IHVybC5wYXJzZSgpIGJlaGF2ZWQuXG4gICAgICAgICAgICBvcHRpb25zUGFyc2VkID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IG9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBvcHRpb25zUGFyc2VkLnBhdGggfHwgJy8nO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdpbiA9IGAke29wdGlvbnNQYXJzZWQucHJvdG9jb2wgfHwgJ2h0dHA6J30vLyR7b3B0aW9uc1BhcnNlZC5ob3N0fWA7XG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUGFyc2VkLCBleHRyYU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiB1cmwuVVJMKSB7XG4gICAgICAgIG9wdGlvbnNQYXJzZWQgPSB7XG4gICAgICAgICAgICBwcm90b2NvbDogb3B0aW9ucy5wcm90b2NvbCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB0eXBlb2Ygb3B0aW9ucy5ob3N0bmFtZSA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmhvc3RuYW1lLFxuICAgICAgICAgICAgcGF0aDogYCR7b3B0aW9ucy5wYXRobmFtZSB8fCAnJ30ke29wdGlvbnMuc2VhcmNoIHx8ICcnfWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnBvcnQgIT09ICcnKSB7XG4gICAgICAgICAgICBvcHRpb25zUGFyc2VkLnBvcnQgPSBOdW1iZXIob3B0aW9ucy5wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy51c2VybmFtZSB8fCBvcHRpb25zLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBvcHRpb25zUGFyc2VkLmF1dGggPSBgJHtvcHRpb25zLnVzZXJuYW1lfToke29wdGlvbnMucGFzc3dvcmR9YDtcbiAgICAgICAgfVxuICAgICAgICBwYXRobmFtZSA9IG9wdGlvbnMucGF0aG5hbWU7XG4gICAgICAgIG9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuICAgICAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1BhcnNlZCwgZXh0cmFPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1BhcnNlZCA9IE9iamVjdC5hc3NpZ24oeyBwcm90b2NvbDogb3B0aW9ucy5ob3N0ID8gJ2h0dHA6JyA6IHVuZGVmaW5lZCB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBvcHRpb25zUGFyc2VkLmhvc3QgfHxcbiAgICAgICAgICAgIChvcHRpb25zUGFyc2VkLnBvcnQgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYCR7b3B0aW9uc1BhcnNlZC5ob3N0bmFtZX0ke29wdGlvbnNQYXJzZWQucG9ydH1gXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zUGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgICAgb3JpZ2luID0gYCR7b3B0aW9uc1BhcnNlZC5wcm90b2NvbCB8fCAnaHR0cDonfS8vJHtob3N0bmFtZX1gO1xuICAgICAgICBwYXRobmFtZSA9IG9wdGlvbnMucGF0aG5hbWU7XG4gICAgICAgIGlmICghcGF0aG5hbWUgJiYgb3B0aW9uc1BhcnNlZC5wYXRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwob3B0aW9uc1BhcnNlZC5wYXRoLCBvcmlnaW4pO1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkVXJsLnBhdGhuYW1lIHx8ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc29tZSBwYWNrYWdlcyByZXR1cm4gbWV0aG9kIGluIGxvd2VyY2FzZS4uXG4gICAgLy8gZW5zdXJlIHVwcGVyQ2FzZSBmb3IgY29uc2lzdGVuY3lcbiAgICBjb25zdCBtZXRob2QgPSBvcHRpb25zUGFyc2VkLm1ldGhvZFxuICAgICAgICA/IG9wdGlvbnNQYXJzZWQubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgOiAnR0VUJztcbiAgICByZXR1cm4geyBvcmlnaW4sIHBhdGhuYW1lLCBtZXRob2QsIG9wdGlvbnNQYXJzZWQsIGludmFsaWRVcmwgfTtcbn07XG5leHBvcnRzLmdldFJlcXVlc3RJbmZvID0gZ2V0UmVxdWVzdEluZm87XG4vKipcbiAqIE1ha2VzIHN1cmUgb3B0aW9ucyBpcyBvZiB0eXBlIHN0cmluZyBvciBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zIGZvciB0aGUgcmVxdWVzdFxuICovXG5jb25zdCBpc1ZhbGlkT3B0aW9uc1R5cGUgPSAob3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb3B0aW9ucztcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgKHR5cGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpKTtcbn07XG5leHBvcnRzLmlzVmFsaWRPcHRpb25zVHlwZSA9IGlzVmFsaWRPcHRpb25zVHlwZTtcbmNvbnN0IGV4dHJhY3RIb3N0bmFtZUFuZFBvcnQgPSAocmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLmhvc3RuYW1lICYmIHJlcXVlc3RPcHRpb25zLnBvcnQpIHtcbiAgICAgICAgcmV0dXJuIHsgaG9zdG5hbWU6IHJlcXVlc3RPcHRpb25zLmhvc3RuYW1lLCBwb3J0OiByZXF1ZXN0T3B0aW9ucy5wb3J0IH07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSAoKF9hID0gcmVxdWVzdE9wdGlvbnMuaG9zdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9eKFteOi8gXSspKDpcXGR7MSw1fSk/LykpIHx8IG51bGw7XG4gICAgY29uc3QgaG9zdG5hbWUgPSByZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSB8fCAobWF0Y2hlcyA9PT0gbnVsbCA/ICdsb2NhbGhvc3QnIDogbWF0Y2hlc1sxXSk7XG4gICAgbGV0IHBvcnQgPSByZXF1ZXN0T3B0aW9ucy5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgXCI6XCIuIFRoZSBleHRyYWN0ZWQgcG9ydCB3b3VsZCBiZSBzb21ldGhpbmcgbGlrZSBcIjo4MDgwXCJcbiAgICAgICAgICAgIHBvcnQgPSBtYXRjaGVzWzJdLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcnQgPSByZXF1ZXN0T3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnNDQzJyA6ICc4MCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdG5hbWUsIHBvcnQgfTtcbn07XG5leHBvcnRzLmV4dHJhY3RIb3N0bmFtZUFuZFBvcnQgPSBleHRyYWN0SG9zdG5hbWVBbmRQb3J0O1xuLyoqXG4gKiBSZXR1cm5zIG91dGdvaW5nIHJlcXVlc3QgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge1BhcnNlZFJlcXVlc3RPcHRpb25zfSByZXF1ZXN0T3B0aW9ucyB0aGUgc2FtZSBvcHRpb25zIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdFxuICogQHBhcmFtIHt7IGNvbXBvbmVudDogc3RyaW5nLCBob3N0bmFtZTogc3RyaW5nLCBob29rQXR0cmlidXRlcz86IEF0dHJpYnV0ZXMgfX0gb3B0aW9ucyB1c2VkIHRvIHBhc3MgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7U2VtY29udlN0YWJpbGl0eX0gc2VtY29udlN0YWJpbGl0eSBkZXRlcm1pbmVzIHdoaWNoIHNlbWNvbnYgdmVyc2lvbiB0byB1c2VcbiAqL1xuY29uc3QgZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IChyZXF1ZXN0T3B0aW9ucywgb3B0aW9ucywgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBvcHRpb25zLmhvc3RuYW1lO1xuICAgIGNvbnN0IHBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgY29uc3QgbWV0aG9kID0gKF9hID0gcmVxdWVzdE9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnR0VUJztcbiAgICBjb25zdCBub3JtYWxpemVkTWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgY29uc3QgdXNlckFnZW50ID0gaGVhZGVyc1sndXNlci1hZ2VudCddO1xuICAgIGNvbnN0IHVybEZ1bGwgPSAoMCwgZXhwb3J0cy5nZXRBYnNvbHV0ZVVybCkocmVxdWVzdE9wdGlvbnMsIGhlYWRlcnMsIGAke29wdGlvbnMuY29tcG9uZW50fTpgKTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1VSTF06IHVybEZ1bGwsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTogbWV0aG9kLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1RBUkdFVF06IHJlcXVlc3RPcHRpb25zLnBhdGggfHwgJy8nLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9OQU1FXTogaG9zdG5hbWUsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfSE9TVF06IChfYiA9IGhlYWRlcnMuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYCR7aG9zdG5hbWV9OiR7cG9ydH1gLFxuICAgIH07XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgICAgLy8gUmVxdWlyZWQgYXR0cmlidXRlc1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdOiBub3JtYWxpemVkTWV0aG9kLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXTogaG9zdG5hbWUsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdOiBOdW1iZXIocG9ydCksXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX0ZVTExdOiB1cmxGdWxsLFxuICAgICAgICAvLyBsZWF2aW5nIG91dCBwcm90b2NvbCB2ZXJzaW9uLCBpdCBpcyBub3QgeWV0IG5lZ290aWF0ZWRcbiAgICAgICAgLy8gbGVhdmluZyBvdXQgcHJvdG9jb2wgbmFtZSwgaXQgaXMgb25seSByZXF1aXJlZCB3aGVuIHByb3RvY29sIHZlcnNpb24gaXMgc2V0XG4gICAgICAgIC8vIHJldHJpZXMgYW5kIHJlZGlyZWN0cyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIC8vIE9wdC1pbiBhdHRyaWJ1dGVzIGxlZnQgb2ZmIGZvciBub3dcbiAgICB9O1xuICAgIC8vIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWQgaWYgcmVxdWVzdCBtZXRob2QgcmVxdWlyZWQgY2FzZSBub3JtYWxpemF0aW9uXG4gICAgaWYgKG1ldGhvZCAhPT0gbm9ybWFsaXplZE1ldGhvZCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EX09SSUdJTkFMXSA9IG1ldGhvZDtcbiAgICB9XG4gICAgaWYgKHVzZXJBZ2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1VTRVJfQUdFTlRdID0gdXNlckFnZW50O1xuICAgIH1cbiAgICBzd2l0Y2ggKHNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgb3V0Z29pbmcgcmVxdWVzdCBNZXRyaWMgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9OQU1FXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRV07XG4gICAgLy9UT0RPOiBodHRwLnVybCBhdHRyaWJ1dGUsIGl0IHNob3VsZCBzdWJzdGl0dXRlIGFueSBwYXJhbWV0ZXJzIHRvIGF2b2lkIGhpZ2ggY2FyZGluYWxpdHkuXG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcztcbi8qKlxuICogUmV0dXJucyBhdHRyaWJ1dGVzIHJlbGF0ZWQgdG8gdGhlIGtpbmQgb2YgSFRUUCBwcm90b2NvbCB1c2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdIEtpbmQgb2YgSFRUUCBwcm90b2NvbCB1c2VkOiBcIjEuMFwiLCBcIjEuMVwiLCBcIjJcIiwgXCJTUERZXCIgb3IgXCJRVUlDXCIuXG4gKi9cbmNvbnN0IHNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQgPSAoa2luZCwgYXR0cmlidXRlcykgPT4ge1xuICAgIGlmIChraW5kKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl0gPSBraW5kO1xuICAgICAgICBpZiAoa2luZC50b1VwcGVyQ2FzZSgpICE9PSAnUVVJQycpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfVFJBTlNQT1JUXSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTkVUVFJBTlNQT1JUVkFMVUVTX0lQX1RDUDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfVFJBTlNQT1JUXSA9IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTkVUVFJBTlNQT1JUVkFMVUVTX0lQX1VEUDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQgPSBzZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kO1xuLyoqXG4gKiBSZXR1cm5zIG91dGdvaW5nIHJlcXVlc3QgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlc3BvbnNlIGRhdGFcbiAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHJlc3BvbnNlLCBzZW1jb252U3RhYmlsaXR5KSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBodHRwVmVyc2lvbiwgc29ja2V0IH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0ge307XG4gICAgY29uc3Qgc3RhYmxlQXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChzdGF0dXNDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc3RhYmxlQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0gPSBzdGF0dXNDb2RlO1xuICAgIH1cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlQWRkcmVzcywgcmVtb3RlUG9ydCB9ID0gc29ja2V0O1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfSVBdID0gcmVtb3RlQWRkcmVzcztcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlRdID0gcmVtb3RlUG9ydDtcbiAgICAgICAgLy8gUmVjb21tZW5kZWRcbiAgICAgICAgc3RhYmxlQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX0FERFJFU1NdID0gcmVtb3RlQWRkcmVzcztcbiAgICAgICAgc3RhYmxlQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX1BPUlRdID0gcmVtb3RlUG9ydDtcbiAgICAgICAgc3RhYmxlQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSA9IHJlc3BvbnNlLmh0dHBWZXJzaW9uO1xuICAgIH1cbiAgICAoMCwgZXhwb3J0cy5zZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUpKHJlc3BvbnNlLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICBpZiAoc3RhdHVzQ29kZSkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV0gPSBzdGF0dXNDb2RlO1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW0F0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9TVEFUVVNfVEVYVF0gPSAoc3RhdHVzTWVzc2FnZSB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgKDAsIGV4cG9ydHMuc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCkoaHR0cFZlcnNpb24sIG9sZEF0dHJpYnV0ZXMpO1xuICAgIHN3aXRjaCAoc2VtY29udlN0YWJpbGl0eSkge1xuICAgICAgICBjYXNlIDEgLyogU1RBQkxFICovOlxuICAgICAgICAgICAgcmV0dXJuIHN0YWJsZUF0dHJpYnV0ZXM7XG4gICAgICAgIGNhc2UgMiAvKiBPTEQgKi86XG4gICAgICAgICAgICByZXR1cm4gb2xkQXR0cmlidXRlcztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgc3RhYmxlQXR0cmlidXRlcyk7XG59O1xuZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlO1xuLyoqXG4gKiBSZXR1cm5zIG91dGdvaW5nIHJlcXVlc3QgTWV0cmljIGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXNwb25zZSBkYXRhXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IHNwYW5BdHRyaWJ1dGVzIHRoZSBzcGFuIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlRdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXTtcbiAgICByZXR1cm4gbWV0cmljQXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2U7XG5mdW5jdGlvbiBwYXJzZUhvc3RIZWFkZXIoaG9zdEhlYWRlciwgcHJvdG8pIHtcbiAgICBjb25zdCBwYXJ0cyA9IGhvc3RIZWFkZXIuc3BsaXQoJzonKTtcbiAgICAvLyBubyBzZW1pY29sb24gaW1wbGllcyBpcHY0IGRvdHRlZCBzeW50YXggb3IgaG9zdCBuYW1lIHdpdGhvdXQgcG9ydFxuICAgIC8vIHgueC54LnhcbiAgICAvLyBleGFtcGxlLmNvbVxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHByb3RvID09PSAnaHR0cCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IHBhcnRzWzBdLCBwb3J0OiAnODAnIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3RvID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBwYXJ0c1swXSwgcG9ydDogJzQ0MycgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBob3N0OiBwYXJ0c1swXSB9O1xuICAgIH1cbiAgICAvLyBzaW5nbGUgc2VtaWNvbG9uIGltcGxpZXMgaXB2NCBkb3R0ZWQgc3ludGF4IG9yIGhvc3QgbmFtZSB3aXRoIHBvcnRcbiAgICAvLyB4LngueC54Onl5eXlcbiAgICAvLyBleGFtcGxlLmNvbTp5eXl5XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogcGFydHNbMF0sXG4gICAgICAgICAgICBwb3J0OiBwYXJ0c1sxXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gbW9yZSB0aGFuIDIgcGFydHMgaW1wbGllcyBpcHY2IHN5bnRheCB3aXRoIG11bHRpcGxlIGNvbG9uc1xuICAgIC8vIFt4Ong6eDp4Ong6eDp4OnhdXG4gICAgLy8gW3g6eDp4Ong6eDp4Ong6eF06eXl5eVxuICAgIGlmIChwYXJ0c1swXS5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogaG9zdEhlYWRlciwgcG9ydDogJzgwJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3RvID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogaG9zdEhlYWRlciwgcG9ydDogJzQ0MycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKCc6JyksXG4gICAgICAgICAgICAgICAgcG9ydDogcGFydHNbcGFydHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vdGhpbmcgYWJvdmUgbWF0Y2hlcyBqdXN0IHJldHVybiB0aGUgaG9zdCBoZWFkZXJcbiAgICByZXR1cm4geyBob3N0OiBob3N0SGVhZGVyIH07XG59XG4vKipcbiAqIEdldCBzZXJ2ZXIuYWRkcmVzcyBhbmQgcG9ydCBhY2NvcmRpbmcgdG8gaHR0cCBzZW1jb252IDEuMjdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9ibG9iL2JmMGEyYzExMzRmMjA2ZjAzNDQwOGIyMDFkYmVjMzc5NjBlZDYwZWMvZG9jcy9odHRwL2h0dHAtc3BhbnMubWQjc2V0dGluZy1zZXJ2ZXJhZGRyZXNzLWFuZC1zZXJ2ZXJwb3J0LWF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0U2VydmVyQWRkcmVzcyhyZXF1ZXN0LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBmb3J3YXJkZWRIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNbJ2ZvcndhcmRlZCddO1xuICAgIGlmIChmb3J3YXJkZWRIZWFkZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBwYXJzZUZvcndhcmRlZEhlYWRlcihmb3J3YXJkZWRIZWFkZXIpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuaG9zdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoZW50cnkuaG9zdCwgZW50cnkucHJvdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHhGb3J3YXJkZWRIb3N0ID0gcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1ob3N0J107XG4gICAgaWYgKHR5cGVvZiB4Rm9yd2FyZGVkSG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0LCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3QsIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeEZvcndhcmRlZEhvc3QpICYmXG4gICAgICAgIHR5cGVvZiB4Rm9yd2FyZGVkSG9zdFswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgeEZvcndhcmRlZEhvc3RbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3RbMF0sIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdFswXSwgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0WzBdKTtcbiAgICB9XG4gICAgY29uc3QgaG9zdCA9IHJlcXVlc3QuaGVhZGVyc1snaG9zdCddO1xuICAgIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycgJiYgaG9zdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoaG9zdCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldCBzZXJ2ZXIuYWRkcmVzcyBhbmQgcG9ydCBhY2NvcmRpbmcgdG8gaHR0cCBzZW1jb252IDEuMjdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9ucy9ibG9iL2JmMGEyYzExMzRmMjA2ZjAzNDQwOGIyMDFkYmVjMzc5NjBlZDYwZWMvZG9jcy9odHRwL2h0dHAtc3BhbnMubWQjc2V0dGluZy1zZXJ2ZXJhZGRyZXNzLWFuZC1zZXJ2ZXJwb3J0LWF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgZm9yd2FyZGVkSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzWydmb3J3YXJkZWQnXTtcbiAgICBpZiAoZm9yd2FyZGVkSGVhZGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcGFyc2VGb3J3YXJkZWRIZWFkZXIoZm9yd2FyZGVkSGVhZGVyKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmZvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5mb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeEZvcndhcmRlZEZvciA9IHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ107XG4gICAgaWYgKHR5cGVvZiB4Rm9yd2FyZGVkRm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geEZvcndhcmRlZEZvcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4Rm9yd2FyZGVkRm9yKSkge1xuICAgICAgICByZXR1cm4geEZvcndhcmRlZEZvclswXTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3RlID0gcmVxdWVzdC5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5nZXRSZW1vdGVDbGllbnRBZGRyZXNzID0gZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcztcbmZ1bmN0aW9uIGdldEluZm9Gcm9tSW5jb21pbmdNZXNzYWdlKGNvbXBvbmVudCwgcmVxdWVzdCwgbG9nZ2VyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzLmhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKChfYSA9IHJlcXVlc3QudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnLycsIGAke2NvbXBvbmVudH06Ly8ke3JlcXVlc3QuaGVhZGVycy5ob3N0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUGFyc2VkVXJsID0gbmV3IFVSTCgoX2IgPSByZXF1ZXN0LnVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJy8nLCBcbiAgICAgICAgICAgIC8vIHVzaW5nIGxvY2FsaG9zdCBhcyBhIHdvcmthcm91bmQgdG8gc3RpbGwgdXNlIHRoZSBVUkwgY29uc3RydWN0b3IgZm9yIHBhcnNpbmdcbiAgICAgICAgICAgIGAke2NvbXBvbmVudH06Ly9sb2NhbGhvc3RgKTtcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIHVzZSBsb2NhbGhvc3QgYXMgYSB3b3JrYXJvdW5kLCBlbnN1cmUgd2UgaGlkZSB0aGUgcmVzdCBvZiB0aGUgcHJvcGVydGllcyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gb3VyIHdvcmthcm91bmQgbGVha2luZyB0aG91Z2guXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiB1bnNhZmVQYXJzZWRVcmwucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiB1bnNhZmVQYXJzZWRVcmwuc2VhcmNoLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCB1c2UgdGhlIHJlc3VsdCBvZiB1bnNhZmVQYXJzZWRVcmwudG9TdHJpbmcgYXMgaXQncyBwb3RlbnRpYWxseSB3cm9uZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuc2FmZVBhcnNlZFVybC5wYXRobmFtZSArIHVuc2FmZVBhcnNlZFVybC5zZWFyY2g7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIGlzIHdyb25nLCB1c2UgdW5kZWZpbmVkIC0gdGhpcyAqc2hvdWxkKiBuZXZlciBoYXBwZW4sIGxvZ2dpbmdcbiAgICAgICAgLy8gZm9yIHRyb3VibGVzaG9vdGluZyBpbiBjYXNlIGl0IGRvZXMgaGFwcGVuLlxuICAgICAgICBsb2dnZXIudmVyYm9zZSgnVW5hYmxlIHRvIGdldCBVUkwgZnJvbSByZXF1ZXN0JywgZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gcmVxdWVzdCB0aGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7eyBjb21wb25lbnQ6IHN0cmluZywgc2VydmVyTmFtZT86IHN0cmluZywgaG9va0F0dHJpYnV0ZXM/OiBBdHRyaWJ1dGVzIH19IG9wdGlvbnMgdXNlZCB0byBwYXNzIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSAocmVxdWVzdCwgb3B0aW9ucywgbG9nZ2VyKSA9PiB7XG4gICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBoZWFkZXJzWyd1c2VyLWFnZW50J107XG4gICAgY29uc3QgaXBzID0gaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ107XG4gICAgY29uc3QgaHR0cFZlcnNpb24gPSByZXF1ZXN0Lmh0dHBWZXJzaW9uO1xuICAgIGNvbnN0IGhvc3QgPSBoZWFkZXJzLmhvc3Q7XG4gICAgY29uc3QgaG9zdG5hbWUgPSAoaG9zdCA9PT0gbnVsbCB8fCBob3N0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0LnJlcGxhY2UoL14oLiopKDpbMC05XXsxLDV9KS8sICckMScpKSB8fCAnbG9jYWxob3N0JztcbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBjb25zdCBub3JtYWxpemVkTWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCk7XG4gICAgY29uc3Qgc2VydmVyQWRkcmVzcyA9IGdldFNlcnZlckFkZHJlc3MocmVxdWVzdCwgb3B0aW9ucy5jb21wb25lbnQpO1xuICAgIGNvbnN0IHNlcnZlck5hbWUgPSBvcHRpb25zLnNlcnZlck5hbWU7XG4gICAgY29uc3QgcmVtb3RlQ2xpZW50QWRkcmVzcyA9IGdldFJlbW90ZUNsaWVudEFkZHJlc3MocmVxdWVzdCk7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogbm9ybWFsaXplZE1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfU0NIRU1FXTogb3B0aW9ucy5jb21wb25lbnQsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdOiBzZXJ2ZXJBZGRyZXNzID09PSBudWxsIHx8IHNlcnZlckFkZHJlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlckFkZHJlc3MuaG9zdCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfQUREUkVTU106IHJlcXVlc3Quc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX1BPUlRdOiByZXF1ZXN0LnNvY2tldC5yZW1vdGVQb3J0LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl06IHJlcXVlc3QuaHR0cFZlcnNpb24sXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVNFUl9BR0VOVF9PUklHSU5BTF06IHVzZXJBZ2VudCxcbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IGdldEluZm9Gcm9tSW5jb21pbmdNZXNzYWdlKG9wdGlvbnMuY29tcG9uZW50LCByZXF1ZXN0LCBsb2dnZXIpO1xuICAgIGlmICgocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnBhdGhuYW1lKSAhPSBudWxsKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9QQVRIXSA9IHBhcnNlZFVybC5wYXRobmFtZTtcbiAgICB9XG4gICAgaWYgKHJlbW90ZUNsaWVudEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9DTElFTlRfQUREUkVTU10gPSByZW1vdGVDbGllbnRBZGRyZXNzO1xuICAgIH1cbiAgICBpZiAoKHNlcnZlckFkZHJlc3MgPT09IG51bGwgfHwgc2VydmVyQWRkcmVzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmVyQWRkcmVzcy5wb3J0KSAhPSBudWxsKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXSA9IE51bWJlcihzZXJ2ZXJBZGRyZXNzLnBvcnQpO1xuICAgIH1cbiAgICAvLyBjb25kaXRpb25hbGx5IHJlcXVpcmVkIGlmIHJlcXVlc3QgbWV0aG9kIHJlcXVpcmVkIGNhc2Ugbm9ybWFsaXphdGlvblxuICAgIGlmIChtZXRob2QgIT09IG5vcm1hbGl6ZWRNZXRob2QpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF9PUklHSU5BTF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVVJMXTogcGFyc2VkVXJsLnRvU3RyaW5nKCksXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfSE9TVF06IGhvc3QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX05BTUVdOiBob3N0bmFtZSxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdOiBtZXRob2QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU0NIRU1FXTogb3B0aW9ucy5jb21wb25lbnQsXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGlwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfQ0xJRU5UX0lQXSA9IGlwcy5zcGxpdCgnLCcpWzBdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlcnZlck5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NFUlZFUl9OQU1FXSA9IHNlcnZlck5hbWU7XG4gICAgfVxuICAgIGlmIChwYXJzZWRVcmwgPT09IG51bGwgfHwgcGFyc2VkVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVEFSR0VUXSA9XG4gICAgICAgICAgICAocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnBhdGhuYW1lKSArIChwYXJzZWRVcmwgPT09IG51bGwgfHwgcGFyc2VkVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRVcmwuc2VhcmNoKSB8fCAnLyc7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VU0VSX0FHRU5UXSA9IHVzZXJBZ2VudDtcbiAgICB9XG4gICAgKDAsIGV4cG9ydHMuc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGUpKHJlcXVlc3QsIG9sZEF0dHJpYnV0ZXMpO1xuICAgICgwLCBleHBvcnRzLnNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQpKGh0dHBWZXJzaW9uLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuc2VtY29udlN0YWJpbGl0eSkge1xuICAgICAgICBjYXNlIDEgLyogU1RBQkxFICovOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG4gICAgICAgIGNhc2UgMiAvKiBPTEQgKi86XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgbmV3QXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzID0gZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcztcbi8qKlxuICogUmV0dXJucyBpbmNvbWluZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IHNwYW5BdHRyaWJ1dGVzIHRoZSBzcGFuIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7eyBjb21wb25lbnQ6IHN0cmluZyB9fSBvcHRpb25zIHVzZWQgdG8gcGFzcyBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYXR0cmlidXRlc1xuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NDSEVNRV0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU0NIRU1FXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX05BTUVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9OQU1FXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl07XG4gICAgLy9UT0RPOiBodHRwLnRhcmdldCBhdHRyaWJ1dGUsIGl0IHNob3VsZCBzdWJzdGl0dXRlIGFueSBwYXJhbWV0ZXJzIHRvIGF2b2lkIGhpZ2ggY2FyZGluYWxpdHkuXG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcztcbi8qKlxuICogUmV0dXJucyBpbmNvbWluZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXNwb25zZSBkYXRhXG4gKiBAcGFyYW0geyhTZXJ2ZXJSZXNwb25zZSAmIHsgc29ja2V0OiBTb2NrZXQ7IH0pfSByZXNwb25zZSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKi9cbmNvbnN0IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHJlcXVlc3QsIHJlc3BvbnNlLCBzZW1jb252U3RhYmlsaXR5KSA9PiB7XG4gICAgLy8gdGFrZSBzb2NrZXQgZnJvbSB0aGUgcmVxdWVzdCxcbiAgICAvLyBzaW5jZSBpdCBtYXkgYmUgZGV0YWNoZWQgZnJvbSB0aGUgcmVzcG9uc2Ugb2JqZWN0IGluIGtlZXAtYWxpdmUgbW9kZVxuICAgIGNvbnN0IHsgc29ja2V0IH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTogc3RhdHVzQ29kZSxcbiAgICB9O1xuICAgIGNvbnN0IHJwY01ldGFkYXRhID0gKDAsIGNvcmVfMS5nZXRSUENNZXRhZGF0YSkoYXBpXzEuY29udGV4dC5hY3RpdmUoKSk7XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgeyBsb2NhbEFkZHJlc3MsIGxvY2FsUG9ydCwgcmVtb3RlQWRkcmVzcywgcmVtb3RlUG9ydCB9ID0gc29ja2V0O1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfSVBdID0gbG9jYWxBZGRyZXNzO1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfUE9SVF0gPSBsb2NhbFBvcnQ7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9JUF0gPSByZW1vdGVBZGRyZXNzO1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVF0gPSByZW1vdGVQb3J0O1xuICAgIH1cbiAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV0gPSBzdGF0dXNDb2RlO1xuICAgIG9sZEF0dHJpYnV0ZXNbQXR0cmlidXRlTmFtZXNfMS5BdHRyaWJ1dGVOYW1lcy5IVFRQX1NUQVRVU19URVhUXSA9IChzdGF0dXNNZXNzYWdlIHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICgocnBjTWV0YWRhdGEgPT09IG51bGwgfHwgcnBjTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJwY01ldGFkYXRhLnR5cGUpID09PSBjb3JlXzEuUlBDVHlwZS5IVFRQICYmIHJwY01ldGFkYXRhLnJvdXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdID0gcnBjTWV0YWRhdGEucm91dGU7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUk9VVEVdID0gcnBjTWV0YWRhdGEucm91dGU7XG4gICAgfVxuICAgIHN3aXRjaCAoc2VtY29udlN0YWJpbGl0eSkge1xuICAgICAgICBjYXNlIDEgLyogU1RBQkxFICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ld0F0dHJpYnV0ZXM7XG4gICAgICAgIGNhc2UgMiAvKiBPTEQgKi86XG4gICAgICAgICAgICByZXR1cm4gb2xkQXR0cmlidXRlcztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlO1xuLyoqXG4gKiBSZXR1cm5zIGluY29taW5nIHJlcXVlc3QgTWV0cmljIGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7QXR0cmlidXRlc30gc3BhbkF0dHJpYnV0ZXMgdGhlIHNwYW4gYXR0cmlidXRlc1xuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9QT1JUXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfUE9SVF07XG4gICAgaWYgKHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdO1xuICAgIH1cbiAgICByZXR1cm4gbWV0cmljQXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2U7XG5jb25zdCBnZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUk9VVEVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9ST1VURV0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdO1xuICAgIH1cbiAgICAvLyByZXF1aXJlZCBpZiBhbmQgb25seSBpZiBvbmUgd2FzIHNlbnQsIHNhbWUgYXMgc3BhbiByZXF1aXJlbWVudFxuICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0pIHtcbiAgICAgICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0gPVxuICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdO1xuICAgIH1cbiAgICByZXR1cm4gbWV0cmljQXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2U7XG5mdW5jdGlvbiBoZWFkZXJDYXB0dXJlKHR5cGUsIGhlYWRlcnMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaGVhZGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZEhlYWRlciA9IGhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbm9ybWFsaXplZEhlYWRlcnMuc2V0KGNhcHR1cmVkSGVhZGVyLCBjYXB0dXJlZEhlYWRlci5yZXBsYWNlKC8tL2csICdfJykpO1xuICAgIH1cbiAgICByZXR1cm4gKHNwYW4sIGdldEhlYWRlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNhcHR1cmVkSGVhZGVyIG9mIG5vcm1hbGl6ZWRIZWFkZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRIZWFkZXIoY2FwdHVyZWRIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXIgPSBub3JtYWxpemVkSGVhZGVycy5nZXQoY2FwdHVyZWRIZWFkZXIpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYGh0dHAuJHt0eXBlfS5oZWFkZXIuJHtub3JtYWxpemVkSGVhZGVyfWA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmhlYWRlckNhcHR1cmUgPSBoZWFkZXJDYXB0dXJlO1xuY29uc3QgS05PV05fTUVUSE9EUyA9IG5ldyBTZXQoW1xuICAgIC8vIG1ldGhvZHMgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMC5odG1sI25hbWUtbWV0aG9kc1xuICAgICdHRVQnLFxuICAgICdIRUFEJyxcbiAgICAnUE9TVCcsXG4gICAgJ1BVVCcsXG4gICAgJ0RFTEVURScsXG4gICAgJ0NPTk5FQ1QnLFxuICAgICdPUFRJT05TJyxcbiAgICAnVFJBQ0UnLFxuICAgIC8vIFBBVENIIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzU3ODkuaHRtbFxuICAgICdQQVRDSCcsXG5dKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdHRVQnO1xuICAgIH1cbiAgICBjb25zdCB1cHBlciA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChLTk9XTl9NRVRIT0RTLmhhcyh1cHBlcikpIHtcbiAgICAgICAgcmV0dXJuIHVwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gJ19PVEhFUic7XG59XG5mdW5jdGlvbiBwYXJzZUZvcndhcmRlZEhlYWRlcihoZWFkZXIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm9yd2FyZGVkUGFyc2UoaGVhZGVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\n");

/***/ }),

/***/ "(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.VERSION = '0.57.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wcmFraGFyL0RvY3VtZW50cy9vcGVuc19zb3VyY2VfY29udHJpYnV0aW9uXzIvbGlhbS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlZFUlNJT04gPSAnMC41Ny4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../../node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\n");

/***/ })

};
;