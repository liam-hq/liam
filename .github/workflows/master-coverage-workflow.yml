name: Master Coverage Workflow

on:
  schedule:
    - cron: "0 0 * * 1" # every monday 9:00 JST
  workflow_dispatch:

jobs:
  master_coverage_analysis:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
    timeout-minutes: 30
    permissions:
      contents: read
      issues: write
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: main
      
      - uses: ./.github/actions/pnpm-setup
      
      - name: Setup Supabase for tests
        run: pnpm --filter @liam-hq/db supabase:start
      
      - name: Setup environment
        run: |
          cp .env.template .env
          chmod +x ./scripts/extract-supabase-anon-key.sh ./scripts/extract-supabase-service-key.sh
          ./scripts/extract-supabase-anon-key.sh
          ./scripts/extract-supabase-service-key.sh
      
      - name: Run coverage analysis
        run: |
          mkdir -p coverage-reports
          pnpm test:turbo -- --coverage --reporter=json
          find . -name "coverage" -type d -exec find {} -name "coverage-final.json" \; > coverage-files.txt
          
      - name: Analyze coverage and create issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat > analyze-coverage.js << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          const COVERAGE_THRESHOLD = 80;
          
          const coverageFiles = fs.readFileSync('coverage-files.txt', 'utf8')
            .split('\n')
            .filter(file => file.trim());
          
          const lowCoverageFiles = [];
          
          coverageFiles.forEach(coverageFile => {
            if (!fs.existsSync(coverageFile)) return;
            
            try {
              const coverage = JSON.parse(fs.readFileSync(coverageFile, 'utf8'));
              
              Object.entries(coverage).forEach(([filePath, fileData]) => {
                if (filePath.includes('.test.') || 
                    filePath.includes('.spec.') || 
                    filePath.includes('node_modules') ||
                    filePath.includes('__tests__') ||
                    filePath.includes('.stories.')) {
                  return;
                }
                
                const { lines, functions, branches, statements } = fileData.summary || {};
                const lineCoverage = lines ? (lines.covered / lines.total) * 100 : 100;
                const functionCoverage = functions ? (functions.covered / functions.total) * 100 : 100;
                const branchCoverage = branches ? (branches.covered / branches.total) * 100 : 100;
                const statementCoverage = statements ? (statements.covered / statements.total) * 100 : 100;
                
                const overallCoverage = Math.min(lineCoverage, functionCoverage, branchCoverage, statementCoverage);
                
                if (overallCoverage < COVERAGE_THRESHOLD) {
                  lowCoverageFiles.push({
                    path: filePath.replace(process.cwd() + '/', ''),
                    coverage: overallCoverage.toFixed(2),
                    lines: lineCoverage.toFixed(2),
                    functions: functionCoverage.toFixed(2),
                    branches: branchCoverage.toFixed(2),
                    statements: statementCoverage.toFixed(2)
                  });
                }
              });
            } catch (error) {
              console.error(`Error parsing coverage file ${coverageFile}:`, error);
            }
          });
          
          console.log(`Found ${lowCoverageFiles.length} files with coverage below ${COVERAGE_THRESHOLD}%`);
          
          lowCoverageFiles.forEach(file => {
            const title = `Low test coverage: ${file.path} (${file.coverage}%)`;
            const body = `## Test Coverage Issue
          
          **File:** \`${file.path}\`
          **Overall Coverage:** ${file.coverage}%
          
          ### Coverage Breakdown
          - **Lines:** ${file.lines}%
          - **Functions:** ${file.functions}%
          - **Branches:** ${file.branches}%
          - **Statements:** ${file.statements}%
          
          ### Action Required
          This file has test coverage below the 80% threshold. Please add tests to improve coverage.
          
          ### Generated by
          Master Coverage Workflow - ${new Date().toISOString().split('T')[0]}
          `;
          
            try {
              const existingIssues = execSync(
                `gh issue list --search "Low test coverage: ${file.path}" --json title,number --limit 10`,
                { encoding: 'utf8' }
              );
              
              const issues = JSON.parse(existingIssues);
              const existingIssue = issues.find(issue => 
                issue.title.includes(`Low test coverage: ${file.path}`)
              );
              
              if (existingIssue) {
                console.log(`Issue already exists for ${file.path}: #${existingIssue.number}`);
                execSync(`gh issue edit ${existingIssue.number} --body "${body.replace(/"/g, '\\"')}"`, 
                  { stdio: 'inherit' });
              } else {
                execSync(`gh issue create --title "${title}" --body "${body.replace(/"/g, '\\"')}" --label "test-coverage"`, 
                  { stdio: 'inherit' });
                console.log(`Created issue for ${file.path}`);
              }
            } catch (error) {
              console.error(`Error creating issue for ${file.path}:`, error);
            }
          });
          EOF
          
          node analyze-coverage.js
